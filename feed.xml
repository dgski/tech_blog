<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>David Gorski&#x27;s Tech Blog</title>
    <link href="https://tech.davidgorski.ca/feed.xml" rel="self" />
    <link href="https://tech.davidgorski.ca" />
    <updated>2023-05-20T16:18:36-04:00</updated>
    <author>
        <name>David Gorski</name>
    </author>
    <id>https://tech.davidgorski.ca</id>

    <entry>
        <title>A Simple Personal Data Backup Setup</title>
        <author>
            <name>David Gorski</name>
        </author>
        <link href="https://tech.davidgorski.ca/a-simple-personal-data-backup-setup.html"/>
        <id>https://tech.davidgorski.ca/a-simple-personal-data-backup-setup.html</id>

        <updated>2023-05-20T15:54:16-04:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div>
<div>Until recently, my only computer was a 2013 MacBook Air. I backed it up using the included Time Machine system and an external spinning disk hard drive. With the nature of it being a laptop, I didn't have the external drive plugged in all the time, and so I set a calendar reminder to do a weekly backup because I knew I wouldn't do it daily. It's embarrassing to admit that even as a 'tech professional', there were plenty of weeks that I skipped backing up my content. I was used to the computer working all the time, I was busy and I always had some excuse to ignore the reminders. MacOS Notifications would beg me to do something:</div>
<br>
<div>```</div>
<div>It has been 3 weeks since you backed up your computer! You're asking for data loss chump!</div>
<div>```</div>
<br>
<div>It's pretty obvious that in order for it to function properly, you need an automatic backup system. Otherwise, human complacency and laziness take over. Your data needs to be backed up without any input from you. Having recently undertaken an initiative to upgrade and enhance my personal technology setup, I knew I could do better.</div>
<br>
<div>## My Overall Requirements</div>
<div>1. Multiple copies of my data to survive hardware/software failure.</div>
<div>2. Live data synchronization between my MacBook and new Linux Workstation.</div>
<div>3. Snapshots available for restore.</div>
<div>4. Remote copies of my data.</div>
<br>
<div>## The Guiding Principle - 3,2,1</div>
<div>This is something that is obvious, but it really is the bare minimum, even for your personal data. The [3,2,1 rule](https://us-cert.cisa.gov/sites/default/files/publications/data_backup_options.pdf) states that you need:</div>
<br>
<div>- **3 backups**: 3 total copies of your data.</div>
<div>- **2 local**: 2 locally available copies.</div>
<div>- **1 remote**: 1 off-site copy.</div>
<br>
<div>If you satisfy these requirements, your chance of data loss is incredibly slim.</div>
<br>
<div>## Local First</div>
<div>There are many fancy approaches to create local, automatic, backup systems. Fundamentally, they lean on having a dedicated device, on-prem, holding your data. These options included:</div>
<br>
<div>- Purpose-built Network Attached Storage with multiple storage bays</div>
<div>- Raspberry Pi with added hardware</div>
<div>- Full Data Server</div>
<br>
<div>For my needs, these were a little overkill. I wasn't planning on using my backup as a streaming source or personal media server. I just really needed my data to be synchronized between my Macbook and my Linux Workstation. Surely there must be a simple solution for this? Luckily for me, I found [Syncthing](https://syncthing.net/). I am very satisfied with the operational simplicity of this tool. I can just point the app to my data folder on each device, and it does the rest. The included ignore pattern functionality is also very useful in reducing the synchronization data volume amount. The nice effect of live synchronization is that the data changes are immediately reflected on the other machine.</div>
<br>
<div>However, even though live synchronization maintains two copies of my data it is **not** a replacement for true backups! What if the data became corrupted on one device? The daemon would sync this corruption to the other device and I would lose content! This is what **versioned backups** prevent by creating snapshots of your data at certain points in time. Because my use case is simple, I am delegating versioned backups to the remote backup element.</div>
<br>
<div>## Remote Backups</div>
<div>With a live synchronization system working locally, I set out to add a remote backup portion to the setup. My personal stuff is not mission-critical. Maybe yours is, but mine isn't, so a remote backup frequency of once per day was enough. Anyways, I settled on the following requirements:</div>
<br>
<div>1. **Inexpensive**: I don't want to break the bank.</div>
<div>2. **Encrypted**: I'm not a privacy nut, but something still feels wrong about giving someone else carte blanche access to my data.</div>
<div>3. **Scheduled**: I would like this backup to run once a day.</div>
<div>4. **Open-Source**: This is important for two reasons: I don't want to be locked-in and I want to be sure the app does what it says it does.</div>
<br>
<div>To make a long story short; I ended up using [anacron](https://en.wikipedia.org/wiki/Anacron) and [duplicity](http://duplicity.nongnu.org/) with [Backblaze B2](https://www.backblaze.com/b2/cloud-storage.html) on my Linux Workstation.</div>
<br>
<div>**Anacron** allows task scheduling for devices that are not always on. So if you schedule something to run once a day, as long as your computer is on for a portion of the day; it will run.</div>
<br>
<div>**Duplicity** is an amazing all-in-one encryption and upload command-line backup tool. It supports full and partial backups along with support for most cloud providers. I set it up to delete the partial incremental backups after 30 days and do a full backup to save space in the long run.</div>
<br>
<div>**Backblaze B2** is an solid, inexpensive online storage provider. It provided all the features I needed and is compatible with duplicity out of the box.</div>
<br>
<div>The following is templated copy of my backup script. Please note the **firefox profile backup** and the use of **systemd-inhibit** to prevent shutting down the computer while the backup is in progress:</div>
<br>
<div>```bash</div>
<div># Sync firefox profile into data folder</div>
<div>rsync -a {{FIRFOX_FOLDER}} {{DATA_FOLDER}}</div>
<br>
<div># Push latest changes to cloud</div>
<div>systemd-inhibit --why="Daily Backup In-Progress" duplicity \</div>
<div>--verbosity 8 \</div>
<div>{{DATA_FOLDER}}\</div>
<div>{{CLOUD_ENPOINT_AND_API_KEY}} \</div>
<div>--asynchronous-upload\</div>
<div>--full-if-older-than 1M \</div>
<div>--allow-source-mismatch\</div>
<div>&gt;&gt; {{LOG_FILE}}</div>
<div> </div>
<div>echo "personal backup complete ($(date))" &gt;&gt; {{LOG_FILE}}</div>
<div>```</div>
<br>
<div>## Epilogue</div>
<div>Since setting up this system, not a single part of has failed. And maybe, it never will. But I am no longer embarrassed of my backup system and I sleep a little better at night. Please take this as a reminder to back your important stuff up. Hopefully you'll never have to thank me!</div>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Collector Functions in Scheme</title>
        <author>
            <name>David Gorski</name>
        </author>
        <link href="https://tech.davidgorski.ca/collector-functions-in-scheme.html"/>
        <id>https://tech.davidgorski.ca/collector-functions-in-scheme.html</id>
            <category term="Technology"/>

        <updated>2023-05-20T16:18:36-04:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>The Collector paradigm is a functional way of assembling and processing collections of data. As a design pattern it also offers a few benefits, and at the very least provides a unique academic exercise.</p>
<p>I’ve recently been working through the classic book; <a href="https://www.goodreads.com/book/show/548914.The_Little_Schemer">The Little Schemer</a>, which is a cute and concise introduction to Scheme. The Chapter covering this topic delivered the first real friction, so I took some time to chew through it, understand it, and expand its explanation.</p>
<p>Let’s start by defining a function which takes a list of numbers, and uses the collector paradigm to sort the numbers into two categories, Odd and Even:</p>
<pre><code class="language-scheme">(define sep-odds
  (lambda (lat col)
    (cond
      ((null? lat)
        (col &#39;() &#39;()))
      ((= (modulo (car lat) 2) 0)
        (sep-odds (cdr lat) (lambda (odds evens)
                              (col odds (cons (car lat) evens)))))
      (else
        (sep-odds (cdr lat) (lambda (odds evens)
                                (col (cons (car lat) odds) evens)))))))
</code></pre>
<p>This function will consume two arguments: a list of numbers (lat) and a collector function (col). Its body consist’s of one <strong>cond</strong> statement with 3 branches:</p>
<table>
<thead>
<tr>
<th>Branch</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>(null? lat)</td>
<td>Checks if <strong>lat</strong> is empty</td>
</tr>
<tr>
<td>(= (modulo (car lat) 2) 0)</td>
<td>Checks if the first entry in the list is even</td>
</tr>
<tr>
<td>else</td>
<td>Concludes first list entry must be odd</td>
</tr>
</tbody></table>
<p>Take a note as to how <strong>sep-odds</strong> recurs: It does not build a list in the simple way of functionally building up a collection. Instead, if <strong>sep-odds</strong> is to recur it builds a lambda function which will perform a particular task (in this case using <strong>cons</strong> to prepend the number to one of the lists) and then passes this lambda function to the next call of <strong>sep-odds</strong> as the <strong>col</strong> argument.</p>
<p>Wrapping a task in a lambda is a neat trick: It delays execution of the wrapped code until the lambda is called.</p>
<p>Another neat trick is that <strong>sep-odds</strong> stuffs the previous collector function (bound to <strong>col</strong> as a function parameter) into the new lambda’s body. I like to visualize this as a sandwich, with previous collectors being stuffed inside new ones. Finally, when one of these lambdas is called, it does its work, and then calls the collector function embedded inside it.</p>
<p>For our <strong>sep-odds</strong> function, you may notice that we need to provide an initial collector. Let’s get to it.</p>
<p><strong>First Time with Scheme?</strong> <em>Please Note: (car x) returns the first element of the list x, and (cdr x) returns list x excluding the first element.</em></p>
<p>We will define <strong>list</strong> as our 0th collector. This will be the very centre of the lambda function sandwich:</p>
<pre><code class="language-scheme">(define col-0 list)
</code></pre>
<p>Now let’s step through what happens when we perform the following function call:</p>
<pre><code class="language-scheme">(sep-odds &#39;(1 2 3 4) col-0) ; return value -&gt; ((1 3) (2 4))
</code></pre>
<p><strong>(car lat)</strong> for the first call of sep-odds is <strong>1</strong>, therefore the third condition (<strong>else</strong>) is matched. This will generate a new lambda with <strong>col-0</strong> as <strong>col</strong> and <strong>1 (car lat)</strong> inside it. For clarity, we will label this newly generated lambda function as <strong>col-1</strong>:</p>
<pre><code class="language-scheme">; consumes two lists (odds and evens) and adds 1 to the odds list
(define col-1
  (lambda (odds evens)
    (col-0 (cons 1 odds) evens)))
</code></pre>
<p>This conditional branch will then call sep-odds again, with the rest of the list <strong>(cdr lat)</strong> and the newly-generated <strong>col-1</strong> as arguments:</p>
<pre><code class="language-scheme">(sep-odds &#39;(2 3 4) col-1)
</code></pre>
<p>After this second function call the second conditional branch <strong>(= (modulo (car lat) 2) 0)</strong> is triggered as 2 is an even number. Same story again: a new lambda is built, but this time <strong>col-1</strong> is bound to <strong>col</strong>:</p>
<pre><code class="language-scheme">; consumes two lists (odds and evens) and adds 2 to the evens list
(define col-2
  (lambda (odds evens)
    (col-1 odds (cons 2 evens))))
</code></pre>
<p>Now <strong>col-2</strong> and the remainder of the list will serve as the arguments for the <strong>sep-odds</strong> recursive call:</p>
<pre><code class="language-scheme">(sep-odds &#39;(3 4) col-2)
</code></pre>
<p>We repeat, again with an odd number (<strong>3</strong>):</p>
<pre><code class="language-scheme">; consumes two lists (odds and evens) and adds 3 to the odds list
(define col-3
  (lambda (odds evens)
    (col-2 (cons 3 odds) evens)))
</code></pre>
<p>and our next call:</p>
<pre><code class="language-scheme">(sep-odds &#39;(4) col-3)
</code></pre>
<p>Again, with an even number (<strong>4</strong>):</p>
<pre><code class="language-scheme">; consumes two lists (odds and evens) and adds 4 to the evens list
(define col-4
  (lambda (odds evens)
    (col-3 odds (cons 4 evens))))
</code></pre>
<p>Finally, since the input list is empty, the <strong>null?</strong> conditional is triggered with this final call:</p>
<pre><code class="language-scheme">(sep-odds &#39;() col-4)
</code></pre>
<p>That <strong>null?</strong> conditional applies the <strong>col</strong> function. In this case it is our latest, <strong>col-4</strong>:</p>
<pre><code class="language-scheme">; excerpt:
((null? lat) (col-4 &#39;() &#39;()))
</code></pre>
<p>At this moment our sandwich is at its juiciest. Each layer takes an input from the previous one, as the layers are stripped away. We will begin with the outside ‘bun’ of the sandwich and go inwards. Each collector function calls the collector embedded within it:</p>
<pre><code class="language-scheme">(define col-4
  (lambda (odds evens)
    (col-3 odds (cons 4 evens))))
;   |____|
;     |
;     |
      (define col-3
        (lambda (odds evens)
          (col-2 (cons 3 odds) evens)))
;         |____|
;           |
;           |
            (define col-2
              (lambda (odds evens)
                (col-1 odds (cons 2 evens))))
;               |____|
;                 |
;                 |
                  (define col-1
                    (lambda (odds evens)
                      (col-0 (cons 1 odds) evens)))
</code></pre>
<p>We are lucky we used labels, In reality the lambda generated looks like this:</p>
<pre><code class="language-scheme">(lambda (odds evens)
    ((lambda (odds evens)
          ((lambda (odds evens)
                ((lambda (odds evens)
                      (col-0 (cons 1 odds) evens))
                  odds (cons 2 evens)))
            (cons 3 odds) evens))
      odds (cons 4 evens)))
</code></pre>
<p>And this is how the function calls look with the computed values of the arguments:</p>
<pre><code class="language-scheme">1. (col-4 &#39;() &#39;())
2. (col-3 &#39;() &#39;(4))
3. (col-2 &#39;(3) &#39;(4))
4. (col-1 &#39;(3) &#39;(2 4))
5. (col-0 &#39;(1 3) &#39;(2 4))
6. (list &#39;(1 3) &#39;(2 4))
7. ((1 3) (2 4))
</code></pre>
<p>All of these expressions have the same value.</p>
<p>So now the big question: Why? Why complicate things like this? Why not just use multiple lists as arguments to gather the data we want?</p>
<p>Well, Collector functions offer two advantages: Delayed Execution, and Continuations.</p>
<p>To address the first point, in this example, each generated lambda is doing something relatively inexpensive: using <strong>cons</strong> to prepend a number to a list. But what if it was performing some sort of expensive operation? For example: performing operations on a matrix with massive proportions, or rendering graphics. Perhaps there is hypothetical example where we do not want to do anything computationally expensive until the data input has been completely verified, from start to finish? In that case a collector paradigm would work well. Building the collector works sort of as a type of manifest or queue, of operations to be performed.</p>
<p>Secondly, if you have a function which represents a series of steps, and each step has their own state, you can travel back to these states. In effect, you save a snapshot of that point in time. And in Scheme, since you can pass function along; you can pass these snapshots around. This gives you flexibility to return back to times where data was valid or matched some sort of pattern. One thing that comes to mind is traversing a Tree data structure and if you are exploring the children of a branch, you can pass forward a collector that represents that root, until you reach something you need and feed that data into the collector.</p>

            ]]>
        </content>
    </entry>
</feed>
