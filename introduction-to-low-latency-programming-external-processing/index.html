<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Introduction To Low Latency Programming: External Processing - Tech @ DG</title><meta name="description" content="This post originally appears as a chapter in my new book: ‘Introduction&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://tech.davidgorski.ca/introduction-to-low-latency-programming-external-processing/"><link rel="alternate" type="application/atom+xml" href="https://tech.davidgorski.ca/feed.xml"><link rel="alternate" type="application/json" href="https://tech.davidgorski.ca/feed.json"><meta property="og:title" content="Introduction To Low Latency Programming: External Processing"><meta property="og:site_name" content="Tech @ DG"><meta property="og:description" content="This post originally appears as a chapter in my new book: ‘Introduction&hellip;"><meta property="og:url" content="https://tech.davidgorski.ca/introduction-to-low-latency-programming-external-processing/"><meta property="og:type" content="article"><link rel="preload" href="https://tech.davidgorski.ca/assets/dynamic/fonts/publicsans/publicsans.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://tech.davidgorski.ca/assets/css/style.css?v=1501a03667953b81505b3bfe44bcde3f"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech.davidgorski.ca/introduction-to-low-latency-programming-external-processing/"},"headline":"Introduction To Low Latency Programming: External Processing","datePublished":"2024-03-11T10:39","dateModified":"2024-03-11T10:39","description":"This post originally appears as a chapter in my new book: ‘Introduction&hellip;","author":{"@type":"Person","name":"David Gorski","url":"https://tech.davidgorski.ca/authors/david-gorski/"},"publisher":{"@type":"Organization","name":"David Gorski"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><script async defer="defer" data-website-id="f50301b5-5202-4a86-9509-d0a3ed6ed290" src="https://analytics.xantasoft.com/umami.js"></script></head><body><div class="content"><div class="left-bar"><div class="left-bar__inner"><header class="header"><a class="logo" href="https://tech.davidgorski.ca/">Tech @ DG</a></header></div></div><main class="main"><article class="post"><div class="post__meta post__meta--attop"><div class="post__meta--attop__inner"><div class="post__maintag"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#tag"/></svg> Published in <a href="https://tech.davidgorski.ca/tags/c/" class="metadata__maintag">C++</a></div></div></div><div class="main__inner"><div class="post__meta"><div class="post__author"><div><a href="https://tech.davidgorski.ca/authors/david-gorski/" class="post__author__name">David Gorski</a></div></div><div class="post__date"><time datetime="2024-03-11T10:39">Mar 11, 2024</time></div></div><header class="post__header"><h1 class="post__title">Introduction To Low Latency Programming: External Processing</h1></header><div class="post__entry"><p><em>This post originally appears as a chapter in my new book: ‘Introduction To Low Latency Programming’, a short and approachable entry into the subject. <a href="https://a.co/d/0U6KOfb">Available now for purchase on Amazon</a>.</em></p><p>After heavily scrutinizing your program scope you should be left with some functional requirements that are absolutely mandatory, as well as some latency goals you are aiming for. From here, you can start thinking about which pieces of the program could potentially be extracted from the main execution path, to keep it as fast as possible. For our purposes, the <em>main execution path or task</em> is process, system or function that is measured by our defined metrics. Here are some questions you can ask yourself to prepare for this process:</p><ul><li>What is known before the program even runs?</li><li>Can we use this information to ‘do’ some steps before runtime?</li><li>Does any part of the runtime process need to be done ‘real time’?</li><li>Can any of the runtime steps be isolated into a task that can be packaged into a cohesive unit?</li><li>What is the potential cost of communicating with the main task?</li></ul><h2 id="pre-processing">Pre-processing</h2><p>When we are discussing ‘low latency’ we are almost always referring to latency at runtime. Therefore, if we can remove segments of the program functionality and execute them before we enter our low latency execution; we can effectively get them done for ‘free’.</p><p>If you have a lot of information that is used as an input to the runtime computation available to you before the process is even started, you can attempt to perform some parts of the computation even before the program is run. The following subsections discuss some common approaches.</p><h3 id="configurationinput-files--loading-on-start-up">Configuration/Input Files + Loading On Start Up</h3><p>One approach is to generate configuration/input files and supply them to the process at startup. This is very simple from an operation and code perspective. You can create a separate process, or group of processes, that reads from any number of inputs, performs necessary computations and then outputs the results into a file. This file is then read by the low-latency process at start up. Steps:</p><ol><li>Run external process that completes and generates a file.</li><li>Start the low-latency task/runtime, supplying the file as input.</li></ol><p>Additionally, if you don’t need the preparation functionality to be uncoupled from the process, you can have the main process itself do this computation before it enters the low-latency execution phase. This is simple and has an even lower operational overhead as the preparation code lives in the same code ‘space’ as the low-latency code. Warming process steps:</p><ol><li>Warming up: read various database tables into memory, calculate some weights, etc.</li><li>Enter low-latency runtime loop.</li></ol><h3 id="compile-time-processing">Compile Time Processing</h3><p>Another option is ‘hard-coding’ computation into the executable with compile-time programming options: code generation, templates, and ‘constexpr’ functions, methods and variables. These approaches can help reduce instruction count/cost and branching; both key goals of low latency programming (discussed later in the book). While they can provide ‘the fastest’ runtime, they may also be difficult to use in comparison to runtime options. However, they do allow us to squeeze out maximum performance and are often worth pursuing. They are ‘external’ in the sense that they don’t occur during our low-latency runtime operations, because they don’t occur at all. The removal decision is in some sense a type of processing.</p><h4 id="code-generation">Code Generation</h4><p>Code generation takes on many forms. It is the creation of programs that generate code as output. The inputs provided to the code generation program will determine the end functionality included in the final code. This allows us remove ‘work’ and decision-making out of the final runtime and perform these ‘steps’ before or at compile time. The code generator does not have to meet your low latency goals itself, as it is the final runtime process performance that actually matters. Here is a sample code generation script execution:</p><pre><code class="language-bash">python3 generateCode.py --input inputs.json --output output.cpp
</code></pre><p>The <strong>inputs.json</strong> file will dictate what will be included in the final code within the <strong>output.cpp</strong> file.</p><h4 id="compile-flags-and-templates">Compile Flags and Templates</h4><p>You can build programs that use C++ template arguments for specialization: both for types and values. Then, at compile time you can supply flags that will select the correct specialization. Everything unrelated to your supplied options will not be included in the runtime. The following is a super simple example:</p><pre><code class="language-c++">#ifdef BUYER
  using OrderManager = BuyOrderManager;
#else
  using OrderManager = SellOrderManager;
#endif
System&lt;OrderManager&gt; orderManager;
</code></pre><p>The <code>System</code> class takes <code>OrderManager</code> as a template argument and passes it down to other child members. The value of this template argument changes its runtime behavior at compile time; effectively doing the ‘decision-making’ before the program is executed. Of course, we need to pass in the <code>BUYER</code> flag during compilation:</p><pre><code class="language-bash">g++ -o trade_app trade_app.cpp -DBUYER
</code></pre><h4 id="leveraging-constexpr-utilities">Leveraging ‘constexpr’ Utilities</h4><p>Modern C++ (since C++11) has given us <code>constexpr</code> which allows marking variables, functions, classes and methods with a hint that expressions can be resolved at compile time. Here are the ‘rules’:</p><ul><li>A constexpr variable must be initialized as a constexpr type with a constepxr function. These must be constructed/called with either literals or other constexpr variables as arguments.</li><li>A constexpr function can only take and return constexpr types. The key thing to know is that arguments can be accepted as constexpr, but not passed on as constexpr. Once within the function you cannot guarantee the argument values are known at compile time, even though they might be.</li><li>A constexpr type/class can only have constexpr type members and must at least one constexpr constructor. All scalar types and arrays are considered constexpr.</li></ul><p>Even with this constrained set of functionality, we can do some pretty fancy stuff. All the way from specializing function bodies using template parameters to parsing JSON at compile time. The rabbit hole goes deep. In a way it is a form of ‘code generation’ included in C++. Other languages have other forms of compile time pre-processing.</p><p>Using <code>constexpr if</code> and a template argument to specialize function body:</p><pre><code class="language-c++">
template&lt;bool DoOne&gt;
void process() {
  if constexpr (DoOne) {
    // ...
  } else {
    // ...
  }
}
</code></pre><p>Calculating hash at compile time:</p><pre><code class="language-c++">template&lt;size_t Length&gt;
constexpr size_t hash(const char(&amp;str)[Length]) {
  size_t result = 0;
  for (size_t i = 0; i &lt; (Length - 1); i++) {
    result ^= str[i] &lt;&lt; (i % 8);
  }
  return result;
}

// ...
constexpr auto hashValue = hash(&quot;Hello, World!&quot;);
</code></pre><p>Every subsequent version of C++ has significantly boosted the functionality provided by constexpr. Make as much of your code and static data ‘constexpr’ as possible. I have to note something here; The benefit of constexpr is not just the reduction of instructions. You could do that with your own precalculation and storage of static data in an executable written in assembly. This, however, would be incredibly tedious. <code>constexpr</code> is powerful because it treats compile-time resolved data just as it does code; something that can be understood by the programmer and to be updated as objectives/requirements evolve. That is the true power of the constexpr ‘contract’.</p><h2 id="external-parallel-processing">External Parallel Processing</h2><p>Sometimes information is not known before runtime; it requires input from data received during runtime or is updated throughout the day from external sources or computation. This section will discuss a few ways that external processing can be done when the program is already running.</p><h3 id="separate-process">Separate Process</h3><p>Our first option is to have external processes that perform the extracted tasks. This is usually the case for data that does not require inputs from the process itself. Perhaps this is the result of some grid computing batch result or incoming network data. In any case, after the external process is done, it needs a way to pass this data into the already-running main process. The selection of communication method is dependent on data size and the latency requirement. If this is a change that occurs a few times a day we’d use one approach as opposed to a message that is sent every 10 microseconds.</p><p>If this communication rarely happens we can choose a simple method with a low operational overhead such as writing the results to a file and signalling the already running process to read the file. This would be useful for something like a configuration file change or perhaps loading a new machine learning model weights. <strong>SIGUSR1</strong> and <strong>SIGUSR2</strong> are the signals reserved for the program’s own use. The safest way to do this is to register simple flag-setting handler functions at startup which will be called when the signal is received. Handler complexity itself should be kept to a minimum:</p><pre><code class="language-c++">#include &lt;signal.h&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

// Global variable to indicate if a reload is needed
bool performReload = false;

// Signal handler
void handler(int) {
  performReload = true;
}

int main() {
  // Register signal handler
  signal(SIGUSR1, handler);

  // Enter main loop
  while(true) {
    if (performReload) {
      std::cout &lt;&lt; &quot;Reloading configuration...&quot; &lt;&lt; std::endl;
      performReload = false;
    }
    // Actual work
    std::this_thread::sleep_for(std::chrono::seconds(1));
  }
  return 0;
}
</code></pre><p>However, if this communication stream is almost constant, we would have to select a different option. For low latency programs, the common choice is using shared memory with atomic access operations. This leverages operating system constructs that allow two different processes to access the same block of memory; something forbidden by default. Atomic operations are instructions which guarantee atomic accesses and updates of memory. In simpler terms; you are able to assume that no other thread/process is able to read/write to the variable while you are reading or writing to it. The other accessor will either get the old version or the new version depending on instruction scheduling and/or atomic sequencing level chosen. Without using atomic operations you might read memory with an in-between state. There are multiple levels of guarantee:</p><ul><li>Relaxed</li><li>Consume</li><li>Release</li><li>Acquire</li><li>Acquire/Release</li><li>Sequentially Consistent</li></ul><p>You can read more about them by reading the documentation of <code>std::atomic::memory_order</code>. In general, as you move down the list, the guarantees get stronger and stronger about how memory is to be written/read as other threads/processes do the same. Really think about how your memory will be accessed and what the reader/writer really needs to be guaranteed in order to fulfill their objectives. Keep in mind: stronger guarantees cost more; time-wise.</p><p>Once you have two processes accessing the same memory space, you can design data structures that enable communication between the two. The favorite choice for low latency applications is a ring buffer implemented as a contiguous array in memory. The API/design differs based on different access scenarios; mainly affected by the number of simultaneous consumers or producers. A single producer/consumer queue is very simple to implement. The following example is not optimized, but captures the general idea. Try to walk through how the reader and writer each would access the memory with atomic and non-atomic instructions. Think about how the access indices interact and why they begin with an offset from one another. After reading about <code>std::atomic::memory_order</code>, which guarantees do we need for which operations? By default, they use <code>memory_order_seq_cst</code>; with the strictest guarantees.</p><p>A simple single producer, single consumer wait-free queue:</p><pre><code class="language-c++">template&lt;typename T, size_t N&gt;
class WaitFreeQueue {
  T _data[N];
  std::atomic&lt;size_t&gt; _readSequence = 0;
  std::atomic&lt;size_t&gt; _writeSequence = 1;
public:
  WaitFreeQueue() = default;

  bool tryWrite(T value) {
    const auto nextWriteIndex = _writeSequence % N;
    const auto currentReadIndex = _readSequence % N;
    const bool noRoomLeft = (nextWriteIndex == currentReadIndex);
    if (noRoomLeft) {
      return false;
    }
    _data[nextWriteIndex] = std::move(value);
    _writeSequence.store(nextWriteIndex + 1);
    return true;
  }

  T* tryRead() {
    const auto nextReadIndex = (_readSequence + 1) % N;
    const auto nextWriteIndex = _writeSequence % N;
    const bool noNewData = (nextReadIndex == nextWriteIndex);
    if (noNewData) {
      return nullptr;
    }
    _readSequence.store(nextReadIndex);
    return &amp;_data[nextReadIndex];
  }
};
</code></pre><p>To use this across processes, you would create a shared memory segment and construct this queue in the memory space in <strong>one</strong> process using placement new: <code>new (shared_memory_ptr) WaitFreeQueue&lt;int, 100&gt;();</code>. The other processes would simply interpret the shared memory pointer as the queue and use it.</p><p>If you try to extract the address pointer out of one process and use the raw value in another; your second process would be crashed by the operating system. It would be trying access memory outside its virtual memory space and this is forbidden.</p><h3 id="separate-thread">Separate Thread</h3><p>Sometimes this external computation requires data that the main process provides during runtime. In that case it might be more ergonomic to perform the computation in the same process but on a different thread. For the most part the performance distinction between processes and threads can be blurry. For many operating systems, they operate in the same way once you attach to the same shared memory region. The decision would be more so about the level of coupling you want between the foreground and background task runners. In this section we will be discussing a background task that is: 1. Critical to the runtime of the foreground task. 2. In constant back-and-forth communication with the foreground task. Therefore, it is probably better to use a thread for this job rather than a separate process. This can be summarized into the following:</p><ul><li>Use a process if you want the background task to run uncoupled with the foreground task. I.e. you are okay with each task to run separately.</li><li>Use a thread if you want the background task to be coupled with the foreground task. I.e. you need both tasks to be running constantly.</li></ul><p>One thing to note that is applicable to both separate thread and separate process asynchronous tasks: <strong>The communication mechanism overhead must be less costly to the foreground task then just performing the task itself.</strong> Otherwise, what is the point of doing it in the background?</p><p>Just as with separate processes, using a separate thread to perform tasks will ideally be coordinated using atomic variables as they can allow for ‘wait-free’ operations. You will not be waiting for a non-deterministic amount of time/CPU clock cycles. The same data structures/instructions you use with a separate process can be used across threads.</p><h2 id="chapter-summary">Chapter Summary</h2><ul><li>You can remove expensive computation outside your program to help reduce latency.</li><li>These computations can be done at compile time, at start-up, or in an external thread or process.</li><li>If the processing is done externally, ensure you select the best communication option for the job.</li></ul></div><footer class="post__footer"><div class="post__last-updated">This article was updated on <time datetime="2024-03-11T10:39">Mar 11, 2024</time></div><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-external-processing%2F" class="js-share facebook tltp tltp--top" aria-label="Facebook" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-external-processing%2F&amp;via=Tech%20%40%20DG&amp;text=Introduction%20To%20Low%20Latency%20Programming%3A%20External%20Processing" class="js-share twitter tltp tltp--top" aria-label="Twitter" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="https://pinterest.com/pin/create/button/?url=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-external-processing%2F&amp;media=undefined&amp;description=Introduction%20To%20Low%20Latency%20Programming%3A%20External%20Processing" class="js-share pinterest tltp tltp--top" aria-label="Pinterest" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#pinterest"/></svg> <span>Pinterest</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-external-processing%2F" class="js-share linkedin tltp tltp--top" aria-label="Share with LinkedIn" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div></footer></div></article><div class="post__section post__related"><div class="main__inner"><h3 class="post__section__title">Related post</h3><div class="post__related__wrap"><article class="c-card"><div class="c-card__meta"><div class="c-card__author"><a href="https://tech.davidgorski.ca/authors/david-gorski/">David Gorski</a></div><time datetime="2024-03-04T11:01">Mar 4, 2024 </time><a href="https://tech.davidgorski.ca/tags/c/" class="c-card-tag">C++</a></div><header class="c-card__header"><h2 class="c-card__title"><a href="https://tech.davidgorski.ca/introduction-to-low-latency-programming-understand-storage/">Introduction To Low Latency Programming: Understand Storage</a></h2><p>This post originally appears as a chapter in my new book: ‘Introduction&hellip;</p></header></article><article class="c-card"><div class="c-card__meta"><div class="c-card__author"><a href="https://tech.davidgorski.ca/authors/david-gorski/">David Gorski</a></div><time datetime="2024-02-26T14:42">Feb 26, 2024 </time><a href="https://tech.davidgorski.ca/tags/c/" class="c-card-tag">C++</a></div><header class="c-card__header"><h2 class="c-card__title"><a href="https://tech.davidgorski.ca/introduction-to-low-latency-programming-minimize-branching-and-jumping/">Introduction To Low Latency Programming: Minimize Branching And Jumping</a></h2><p>This post originally appears as a chapter in my new book: ‘Introduction&hellip;</p></header></article></div></div></div></main><div class="right-bar"><div class="right-bar__inner"><div class="sidebar"><section class="box promo"><h3 class="box__title">New Book Available Now!</h3><img src="/media/files/ilp.png"><p>Introduction To Low Latency Programming: Learn The Fundamental Ideas Behind High-Performance C++ Code</p><br><a href="https://a.co/d/0U6KOfb"><button>Buy On Amazon</button></a><br><br><br><h3 class="box__title">Newsletter Subscription Options</h3><ul><li><a href="https://tech.davidgorski.ca/feed.xml">RSS</a></li><li><a href="https://techatdg.substack.com">Email Via Substack</a></li></ul></section><div class="box follow"><a href="https://twitter.com/thedavidgorski" class="tltp tltp--top" aria-label="Twitter"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="https://www.linkedin.com/in/dgski/" class="tltp tltp--top" aria-label="LinkedIn"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div><div class="box copyright">© David Gorski, 2024</div></div></div></div></div><script defer="defer" src="https://tech.davidgorski.ca/assets/js/scripts.min.js?v=12d8fcd46db8fdc7af6797ec26849875"></script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://tech.davidgorski.ca/assets/js/quicklink.umd.js?v=a52ee49fe4afff274f8c30fe880ddc13"></script><script>window.addEventListener('load', () =>{
      quicklink.listen();
      });</script></body></html>