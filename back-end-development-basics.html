<!DOCTYPE html><html lang="en-us" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Back-End Development Basics - David Gorski&#x27;s Tech Blog</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://tech.davidgorski.ca/back-end-development-basics.html"><link rel="alternate" type="application/atom+xml" href="https://tech.davidgorski.ca/feed.xml"><link rel="alternate" type="application/json" href="https://tech.davidgorski.ca/feed.json"><meta property="og:title" content="Back-End Development Basics"><meta property="og:site_name" content="David Gorski's Tech Blog"><meta property="og:description" content=""><meta property="og:url" content="https://tech.davidgorski.ca/back-end-development-basics.html"><meta property="og:type" content="article"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"><link rel="stylesheet" href="https://tech.davidgorski.ca/assets/css/style.css?v=0a84ec904691ac8314428f82627e777a"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech.davidgorski.ca/back-end-development-basics.html"},"headline":"Back-End Development Basics","datePublished":"2020-01-25T12:00","dateModified":"2023-07-29T14:25","description":"","author":{"@type":"Person","name":"David Gorski","url":"https://tech.davidgorski.ca/authors/david-gorski/"},"publisher":{"@type":"Organization","name":"David Gorski"}}</script></head><body><nav class="container-fluid"><ul><li><strong><a id="logo" href="https://tech.davidgorski.ca/">David Gorski&#x27;s Tech Blog</a></strong></li></ul><ul><li><a href="https://davidgorski.ca">About</a></li></ul></nav><main class="container"><div><header><hgroup><h1>Back-End Development Basics</h1><h3><time datetime="2020-01-25T12:00">Jan 25th 2020 </time>By <a href="https://davidgorski.ca" rel="author" title="David Gorski">David Gorski</a></h3></hgroup></header><div id="post-entry"><h2 id="know-your-data">Know your Data</h2><p>It is most important for a back-end developer to understand the characteristics of the Data their software will interact with. This includes both data inflows and data outflows. Questions such as the following need to be asked:</p><ul><li>How much data is incoming?</li><li>What is the shape/type of the data?</li><li>How should this data be processed?</li><li>Where is this data needed or useful?</li><li>What is the corresponding response to this type of data?</li><li>How soon is a response needed?</li></ul><p>After careful deliberation and analysis, implementation details will naturally emerge regarding load balancing, API design, data structures, micro-service division of labor, parallelization of processing, replication, stream-publishing, table design, caching, relational vs key-value etc.</p><p>The data is the canonical source for developing robust back-end endpoints and services. This is relevant from the high-level architectural decisions all the way to direct coding.</p><p>For example, a service which handles low data volume, with simply query parameters, with low amounts of processing (CRUD), with no real-time requirements in response time, can and should be incredibly simple. There is no reason to over-complicate things. A basic load-balancer paired with a simple web-app and simple db is good enough (with regular backups of course).</p><p>Conversely, a service which handles billions of requests a day, with high levels of processing, and many orthogonal services waiting for the data will need specialized streams/queues, parallel processing, advanced backup systems, specialized data structures with aggressive caching.</p><h2 id="architecture">Architecture</h2><h3 id="system-scaling">System scaling</h3><p>For high-performance, high-throughput systems, it is important to get the basics right. Paying attention to the data you are dealing with, and analyzing the space and time complexities of your algorithms is crucial.</p><ul><li>Use appropriate algorithms and data structures</li><li>Lift load on resources as soon as possible. (Early returns, forwarding requests to relevant module, etc)</li><li>Check for and handle errors as early as possible. Prevent propagation of errors.</li><li>Find a good point of modularity (monolith vs microservices)</li><li>As simple as possible data distribution and replication pipeline.</li><li>Determine level of Data normalization (optimize for speed vs optimize for reduction of redundancy)</li></ul><h3 id="maintainability">Maintainability</h3><p>For large systems, it is important to build services for maintainability. This includes using:</p><ul><li>Clean, clear code</li><li>Simple abstractions</li><li>Microservices for separation of concern</li><li>Well-defined, versioned APIS, as well as organization process for creating new endpoints</li><li>Re-use what you can</li><li>Cherry-pick suitable design patterns (SOLID, functional, etcâ€¦), do not force</li></ul></div><div id="author-bio"></div><nav id="post-navigation"><a href="https://tech.davidgorski.ca/the-fixed-point-combinator-function.html" rel="prev">&larr; Previous (The Fixed-Point Combinator Function) </a><a href="https://tech.davidgorski.ca/five-web-project-lessons.html" rel="next">Next (Five Web Project Lessons) &rarr;</a></nav></div></main><footer></footer><script async src="https://tech.davidgorski.ca/assets/js/scripts.js?v=3733efd39cd6c799b95c8fcb96993840"></script></body></html>