{
    "version": "https://jsonfeed.org/version/1",
    "title": "Tech @ DG",
    "description": "",
    "home_page_url": "https://tech.davidgorski.ca",
    "feed_url": "https://tech.davidgorski.ca/feed.json",
    "user_comment": "",
    "author": {
        "name": "David Gorski"
    },
    "items": [
        {
            "id": "https://tech.davidgorski.ca/literary-programming/",
            "url": "https://tech.davidgorski.ca/literary-programming/",
            "title": "Literary Programming",
            "summary": "Code is written once, but read many times. Given this truth, it&hellip;",
            "content_html": "<p>Code is written once, but read many times. Given this truth, it makes sense to prioritize read-ability over write-ability. Readable code contains good variable names, uses appropriate abstractions and is understood easily. Many have waved the flag of ‘Clean Code’ for quite a few decades now.</p>\n<p>What has helped me write code that I consider clear and readable is something I call <em>Literary Programming</em>. Not to be confused with <a href=\"https://en.wikipedia.org/wiki/Literate_programming\">Literate Programming</a>. I would change the name of my concept but I’ve grown rather fond of the name. Apologies in advance.</p>\n<p>What I call <em>Literary Programming</em> is the deliberate application of structured grammar and story-telling into the naming, abstracting and composition of code. It is the conscious act of letting your code capture a narrative with your choice of words. Not leaving intentions and actions in a state of vagueness; method names should reflect what is actually being done within and the meaning of the return value, intermediate variables are encouraged.</p>\n<p>Don’t overanalyze what I am trying to say. This isn’t a very strict set of rules. It may just be synonymous with ‘Good Code’ to you. It is a simple idea meant to inspire a little more scrutiny in you when creating APIs, choosing names, composing expressions and designing the structure of your application.</p>\n<p>Here are just some ways you can make your more <strong>literary</strong>:</p>\n<ul>\n<li>Use abstractions to ‘shorten’ portions of code. Simple example: putting argument and configuration parsing in a separate function to keep the rest of the <code>main</code> as clean as possible.</li>\n<li>Put great care into class API design; as much detail as possible into method names. Prefer a name like <strong>processIncomingMessages()</strong> over <strong>process()</strong> or <strong>messages()</strong>. <strong>getOrCreateItem()</strong> over <strong>getItem()</strong> or <strong>createItem()</strong> for a method that will return an existing object if it already exists.</li>\n<li>Value consistency. One method shouldn’t be named <strong>bool error()</strong> while it’s counterpart is named <strong>bool isValid()</strong>.</li>\n<li>Use intermediate variables to compose expressions. These variables serve as logic checkpoints for the future reader.</li>\n<li>Wrap complicated loop conditions into a boolean-returning functor. Take this call site as an example: <code>while (continueRunning(itemsLeft, maxItemsToProcess, error))</code>.</li>\n<li>As mentioned before; good naming pays dividends.</li>\n</ul>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "style",
                   "Programming"
            ],
            "date_published": "2024-02-09T13:41:04-08:00",
            "date_modified": "2024-02-09T13:43:41-08:00"
        },
        {
            "id": "https://tech.davidgorski.ca/c-mini-pattern-deriving-from-stdvariant/",
            "url": "https://tech.davidgorski.ca/c-mini-pattern-deriving-from-stdvariant/",
            "title": "C++ Pattern: Deriving From std::variant",
            "summary": "I am a big fan of sum types for expressive programming. They&hellip;",
            "content_html": "<p>I am a big fan of sum types for expressive programming. They provide an elegant way to encode mutually exclusive data types in a single field. While not provided by the language itself, the C++ standard library offers us <code>std::variant</code>. Since there is no language-level pattern matching construct, interacting with variants can be less than ergonomic. One way to mitigate this is inheriting from <code>std::variant</code> and creating useful domain-specific access methods. This article discusses a few different ways of deriving from <code>std::variant</code> that might be useful and/or interesting.</p>\n<h2 id=\"a-result-type\">A Result Type</h2>\n<p>To start off we’ll create a ~15 line class derived from <code>std::variant</code> that fulfills the basics of a result type (something like C++23 <code>std::expected</code> but available in C++17 and above). This is a nice way to encapsulate success and failures types in a united interface. Implementation:</p>\n<pre><code class=\"language-c++\">#include &lt;variant&gt;\n\ntemplate&lt;typename T, typename Error&gt;\nclass Result : public std::variant&lt;T, Error&gt; {\npublic:\n  using std::variant&lt;T, Error&gt;::variant;\n  using std::variant&lt;T, Error&gt;::operator=;\n  \n    Error* error() { return std::get_if&lt;Error&gt;(this); }\n    const Error* error() const { return std::get_if&lt;Error&gt;(this); }\n    T* value() { return std::get_if&lt;T&gt;(this); }\n    const T* value() const { return std::get_if&lt;T&gt;(this); }\n    T* operator-&gt;() { return value(); }\n    const T* operator-&gt;() const { return value(); }\n    operator bool() const { return error() == nullptr; }\n};\n</code></pre>\n<p>We derive from <code>std::variant</code> to take advantage of the ergonomic constructors and assignment operators (meaning we don’t have to implement them for each type and each reference type; doing this correctly is tedious). After this, we add two convenient methods to access the underlying types (along with const overloads). And finally, define <code>operator-&gt;</code> to allow access to the underlying success type value and <code>operator bool</code> to determine whether it holds the success type (along with const overloads).</p>\n<p>To demonstrate basic usage we can create a small type hierarchy with success and failure types:</p>\n<pre><code class=\"language-c++\">struct SuccessResult {\n  int date;\n  double time;\n};\nstruct ErrorResult {\n  std::string message;\n};\nusing ProcessResult = Result&lt;SuccessResult, ErrorResult&gt;;\n</code></pre>\n<p>Then we create a function to demonstate it’s usage:</p>\n<pre><code>ProcessResult process(std::string_view input) {\n  return ErrorResult{ &quot;Not implemented&quot; };\n}\n</code></pre>\n<p>And finally we call the function and write some code that observes the return value:</p>\n<pre><code>const auto result = process(&quot;Hello&quot;);\nif (!result) {\n  std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; result.error()-&gt;message &lt;&lt; std::endl;\n} else {\n  std::cout &lt;&lt; &quot;Date: &quot; &lt;&lt; result-&gt;date &lt;&lt; &quot; Time: &quot; &lt;&lt; result-&gt;time &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Overall, this approach is highly ergonomic, concise and clear. The call site is easily understood since <code>operator bool</code> cleanly checks the status, <code>operator -&gt;</code> eliminates unnecessary intermediate variables and method calls. The <code>error()</code> access method is also self-explanatory.</p>\n<h2 id=\"data-or-pointer-to-data\">Data Or Pointer to Data</h2>\n<p>Another potentially useful class we can build is <code>DataOrPointer</code>. This is a class that either holds a type or a pointer to that type. Again we provide ergonomic access methods and operators:</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nclass DataOrPointer : public std::variant&lt;T, T*&gt; {\npublic:\n  using std::variant&lt;T, T*&gt;::variant;\n  using std::variant&lt;T, T*&gt;::operator=;\n  operator const T&amp;() const {\n    if (auto value = std::get_if&lt;T&gt;(this); value) {\n      return *value;\n    }\n    return *std::get&lt;T*&gt;(*this);\n  }\n};\n</code></pre>\n<p>You can use this if you want to provide a single return type to a function that takes a <code>T</code> as an argument and may or may not return a newly constructed <code>T</code> object after testing some conditions. If constructing <code>T</code> is expensive, this approach can be a clean way to achieve the objective. A real-world example of this could be normalizing two BigFloats to use the same exponent before operating on them. If the target exponent is equal to the current exponent, it would be a waste to build a new copy (In this case we can’t mutate the original numbers).</p>\n<pre><code>DataOrPointer&lt;const UnsignedBigFloat&gt; usingExponent(const UnsignedBigFloat&amp; value, int64_t exponent)  {\n    if (exponent == value._exponent) {\n        return DataOrPointer&lt;const UnsignedBigFloat&gt;(&amp;value);\n     }\n\n    auto copy = value;\n    copy._mantissa.timesTenToThe(exponent - value._exponent);\n    copy._exponent = exponent;\n    return std::move(copy);\n}\n</code></pre>\n<h2 id=\"multi-type-reference\">Multi-Type Reference</h2>\n<p>I will admit the following example is almost too esoteric to be useful, but I have actually reached for this once before.</p>\n<p>The challenge: create a reference that can bind to one of multiple types, performance not being critical and reducing code duplication being the main objective.</p>\n<p>Solution:</p>\n<pre><code class=\"language-c++\">template&lt;typename... Ts&gt;\nclass MultiTypeReference : public std::variant&lt;Ts*...&gt; {\npublic:\n  using std::variant&lt;Ts*...&gt;::variant;\n\n  template&lt;typename T&gt;\n  auto&amp; operator=(T value) {\n    std::visit([&amp;](auto&amp; pointer) { *pointer = value; }, *this);\n    return *this;\n  }\n\n  template&lt;typename T&gt;\n  operator T() {\n    return std::visit([&amp;](auto&amp; pointer) { return T(*pointer); }, *this);\n  }\n</code></pre>\n<p>Yes, this works. Yes, it’s weird. No, I don’t encourage you to use it. However, it is an interesting case study and hopefully gets you thinking about how to stretch the use of <code>std::variant</code>. Here’s how one would actually use it:</p>\n<pre><code>struct Data {\n   bool useFieldA;\n   int32_t A;\n     int64_t B;\n};\n\nMultiTypeReference&lt;int32_t, int64_t&gt; getRelevantField(Data&amp; data) {\n    return data.useFieldA ?\n          MultiTypeReference&lt;int32_t, int64_t&gt;(data.A) :\n          MultiTypeReference&lt;int32_t, int64_t&gt;(data.B);\n}\n\nvoid assignOne(Data&amp; one) {\n  getRelevantField(one) = 1;\n}\n</code></pre>\n<p>At the end of the day, yes, this simply hides the conditional access and assignment behind some abstractions. But in use, it behaves exactly how we want it: a reference to one of multiple types.</p>\n<h2 id=\"epilogue\">Epilogue</h2>\n<p>The reason I included the word ‘Pattern’ in the title is because these ideas can be extended to theoretically endless types and custom access methods.</p>\n<p>For examples, you could build a result type with three different possible types and provide access methods for them (removing <code>operator-&gt;</code>). Or perhaps you provide a <code>transform</code> method that takes a functor and changes the value to hold a different type after transforming the current type. Or even just provide custom comparison operators (Which could be necessary for sorting different numeric types; imagine you want to sort a vector of regular int and BigInt references stored within a variant-type).</p>\n<p>In review, the key tools to leverage are:</p>\n<ol>\n<li>Using the constructors and assignment operators provided by <code>std::variant</code>.</li>\n<li>Defining named access methods for different types.</li>\n<li>Providing an <code>operator-&gt;</code> for a success or special type.</li>\n<li>Providing conversion operators for syntax-less unpacking.</li>\n</ol>\n<p>I hope my discussion of these concepts was useful or at least interesting. Thanks for reading! Subscribe via RSS or <a href=\"https://www.linkedin.com/in/dgski/\">LinkedIn</a>.</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
            ],
            "date_published": "2024-01-09T19:00:00-08:00",
            "date_modified": "2024-01-31T17:59:35-08:00"
        },
        {
            "id": "https://tech.davidgorski.ca/c-iterator-friendly-branchless-binary-search/",
            "url": "https://tech.davidgorski.ca/c-iterator-friendly-branchless-binary-search/",
            "title": "C++ Iterator-Friendly Branchless Binary Search",
            "summary": "Once you delve into the realm of low-latency C++, you will find&hellip;",
            "content_html": "<p>Once you delve into the realm of low-latency C++, you will find yourself waking up in the middle of the night, sweating profusely from a nightmare concerning unnecessary branching. And soon after, you begin to over-optimize your code to avoid branches. Even when that part of your code is clearly not the bottleneck.</p>\n<p>This is a short post presenting a C++ iterator-friendly implementation of a branchless binary search implementation. It is short and sweet, so I will reveal it before some editorial comments and thanks:</p>\n<pre><code>template&lt;typename It&gt;\nIt lower_bound(It begin, It end, const typename It::value_type&amp; value) {\n  auto len = std::distance(begin, end);\n  if (len == 0) {\n    return end;\n  }\n\n  while (len &gt; 1) {\n    const auto half = len / 2;\n    begin += (*(begin + half - 1) &lt; value) * half;\n    len -= half;\n  }\n  return (*begin &lt; value) ? end : begin;\n}\n</code></pre>\n<p>This implementation uses a <code>begin</code> iterator and <code>len</code> integer to keep track of the search space rather than begin and end pointers/indices. So the first line of the function are simply using the provided iterators to derive the needed variables. We terminate early if the range is empty. All classic binary search branches within the <code>while</code> loop body have been removed:</p>\n<ul>\n<li>Shrinking the search space length without branches is easy; it will always halve. We can do this safely by subtracting <code>halfLen</code> from the remaining <code>len</code> (This will potentially leave an array of size 1).</li>\n<li>Calculating the new search space start is more tricky. It will either be the same <code>begin</code> as now, or be the halfway point between pos and the end of the search space. So we conditionally add <code>halfLen</code> to <code>begin</code>.</li>\n<li>To conform to the <code>std::lower_bound</code> interface, we must return the end iterator if the value is not found within the range. To do so, unfortunately we must add a final conditional at the end of the function. Thanks to <a href=\"https://www.linkedin.com/in/farid-mehrabi/\">Farhid Mehrabi</a> for pointing this bug out in my initial implementation (I would potentially return a value that is less than the value, breaking the lower bound contract). Adding a simple unit test would have prevented my from doing so, so this a reminder to myself to do so even for small pieces of code.</li>\n</ul>\n<p>For the most part, this implementation will have superior performance to <code>std::lower_bound</code>. There is caveat: since the addition to <code>begin</code> will most likely be turned into a <code>CMOV</code> instruction rather than a proper branch, there will be no prediction to preload the next search space mid-points and at larger array sizes, a classic approach will prevail. This can potentially be mitigated on some platforms by adding an explicit <code>prefetch</code> instruction.</p>\n<p>Thanks to <a href=\"https://en.algorithmica.org/hpc/data-structures/binary-search/\">this amazing article</a> for outlining this concept using raw arrays.</p>\n<h2 id=\"benchmarks\">Benchmarks</h2>\n<p>Nanoseconds taken to find 1000 random numbers that are in the range on Macbook Air M1. <a href=\"https://gist.github.com/dgski/c48142bcb96cc3bf0bf14fe1072e403f\">Code</a>.</p>\n<pre><code>=============================\narray size = 1\nbranchlessTime = 18000\nstdTime        = 18000\n=============================\narray size = 2\nbranchlessTime = 18000\nstdTime        = 30000\n=============================\narray size = 4\nbranchlessTime = 19000\nstdTime        = 39000\n=============================\narray size = 8\nbranchlessTime = 19000\nstdTime        = 48000\n=============================\narray size = 16\nbranchlessTime = 20000\nstdTime        = 59000\n=============================\narray size = 32\nbranchlessTime = 21000\nstdTime        = 69000\n=============================\narray size = 64\nbranchlessTime = 21000\nstdTime        = 78000\n=============================\narray size = 128\nbranchlessTime = 22000\nstdTime        = 91000\n=============================\narray size = 256\nbranchlessTime = 24000\nstdTime        = 103000\n=============================\narray size = 512\nbranchlessTime = 28000\nstdTime        = 113000\n=============================\narray size = 1024\nbranchlessTime = 31000\nstdTime        = 127000\n=============================\narray size = 2048\nbranchlessTime = 35000\nstdTime        = 139000\n=============================\narray size = 4096\nbranchlessTime = 38000\nstdTime        = 146000\n=============================\narray size = 8192\nbranchlessTime = 42000\nstdTime        = 140000\n=============================\narray size = 16384\nbranchlessTime = 40000\nstdTime        = 139000\n=============================\narray size = 32768\nbranchlessTime = 45000\nstdTime        = 149000\n=============================\narray size = 65536\nbranchlessTime = 64000\nstdTime        = 189000\n=============================\narray size = 131072\nbranchlessTime = 79000\nstdTime        = 216000\n=============================\narray size = 262144\nbranchlessTime = 91000\nstdTime        = 233000\n=============================\narray size = 524288\nbranchlessTime = 105000\nstdTime        = 260000\n=============================\narray size = 1048576\nbranchlessTime = 195000\nstdTime        = 351000\n=============================\narray size = 2097152\nbranchlessTime = 142000\nstdTime        = 333000\n=============================\narray size = 4194304\nbranchlessTime = 397000\nstdTime        = 444000\n=============================\narray size = 8388608\nbranchlessTime = 931000\nstdTime        = 961000\n=============================\narray size = 16777216\nbranchlessTime = 1159000\nstdTime        = 996000\n=============================\narray size = 33554432\nbranchlessTime = 1327000\nstdTime        = 1132000\n=============================\narray size = 67108864\nbranchlessTime = 1507000\nstdTime        = 1578000\n=============================\narray size = 134217728\nbranchlessTime = 1603000\nstdTime        = 1710000\n=============================\narray size = 268435456\nbranchlessTime = 5921000\nstdTime        = 5980000\n=============================\narray size = 536870912\nbranchlessTime = 23558000\nstdTime        = 15002000\n</code></pre>\n<p>As you can see the benefits start to deteriorate as the array size grows.</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
            ],
            "date_published": "2023-12-17T11:32:39-08:00",
            "date_modified": "2023-12-18T06:36:35-08:00"
        },
        {
            "id": "https://tech.davidgorski.ca/truncating-string-white-space-at-compile-time-in-c/",
            "url": "https://tech.davidgorski.ca/truncating-string-white-space-at-compile-time-in-c/",
            "title": "Truncating String White-space At Compile Time in C++",
            "summary": "One problem that arises when interleaving SQL queries in C++ code is&hellip;",
            "content_html": "<p>One problem that arises when interleaving SQL queries in C++ code is string literal formatting and spacing. Most queries are much more human-digestible in a multi-line format. C++ treats adjacent string literals as one, so the traditional C++ solution is this:</p>\n<pre><code class=\"language-c++\">const char* query =\n    &quot; SELECT &quot;\n        &quot; u.id, &quot;\n        &quot; u.user_name, &quot;\n        &quot; u.ref_id, &quot;\n        &quot; u.postal_code, &quot;\n        &quot; u.email, &quot;\n        &quot; o.transaction.id &quot;\n    &quot; FROM &quot;\n        &quot; users u &quot;\n    &quot; JOIN &quot;\n        &quot; orders o ON o.user_id = u.id &quot;\n    &quot; WHERE &quot;\n        &quot; u.id=? AND u.active=? &quot;;\n</code></pre>\n<p>A programmer has to be very careful with the white-space before and after the SQL tokens as their presence or lack-thereof could be the difference between a good night’s sleep, or a run-time exception triggering a on-call alert late at night. Fun! Overall this code snippet is much more difficult to read due to the syntactical mess of quotation marks around it. To help prevent issues I have even heard this old platitude from a veteran C++ programmer: “A good surgeon washes his hands before and after the surgery”; mandating spaces at the beginning and end of each line. Is a rule of thumb really a best practice? One’s best work is done with as little distraction as possible, and this is something else to worry about.</p>\n<p>Modern C++ provides us with one useful addition that can help mitigate this issue: the raw string literal. Leveraging this feature we can write the query naturally; all within one pair of quotations:</p>\n<pre><code class=\"language-c++\">const char* query = R&quot;(\n    SELECT\n        u.id,\n        u.user_name,\n        u.ref_id,\n        u.postal_code,\n        u.email,\n        o.transaction.id\n    FROM\n        users u\n    JOIN\n        orders o ON o.user_id = u.id\n    WHERE\n        u.id=? AND u.active=?\n)&quot;;\n</code></pre>\n<p>This works rather well. You can define the same exact query, presented very simply and clear. You don’t have to ‘worry’ about the C++ surrounding the SQL. You can just focus on the SQL. The problem is, all those spaces, tabs and newline characters are also in the final query string. The raw string is <strong>298 characters</strong> long versus the original <strong>166 characters</strong>. This means you pass a query string that is almost <strong>double in length</strong> to any query parsing function/module. Now, with the performance of modern hardware this penalty is negligible. However, sometimes, this code is ran in a hot path or you might have a sense of guilt for such an obvious efficiency sacrifice. Let’s make things right in the universe…</p>\n<p>The first, conceptually simplest, obvious solution is to run a string-slimming function on all queries when program execution starts. This approach is good enough, but all sub-approaches in this branch have disadvantages:</p>\n<ul>\n<li>If you want the query to be ready before a certain function is called, you will unfortunately have to move the query variable out of it’s logical code block. This can reduce the clarity of intent and logic locality.</li>\n<li>If you want to keep the query nested where it’s used, you will have to devise some kind of static initialization function that runs the first time the function is called. A static flag will have to be checked every time the function is called to determine whether the string has been ‘slimmed’ yet.</li>\n<li>You will need to allocate a new destination buffer for the ‘slimmed’ query.</li>\n</ul>\n<p>As suggested by this article’s title we can actually do this string processing at compile time, with no penalty to our code’s logic or clarity. </p>\n<h2 id=\"contexpr-variables-functions-and-classes\">‘contexpr’ Variables, Functions and Classes</h2>\n<p>Modern C++ provides the <a href=\"https://en.cppreference.com/w/cpp/language/constexpr\">constexpr</a> functionality to provide compile-time code utilities. There are a lot of resources available online detailing this, so I won’t go into detail. Fundamentally, you can mark your functions, classes and variables with the <strong>constexpr</strong> keyword to signify they could potentially be called or created at compile time. This is not a guarantee, but a contract of sorts. A summary of the rules:</p>\n<ul>\n<li>A <strong>constexpr variable</strong> must be initialized as a constexpr type with a constepxr function. These must be constructed/called with either literals or other constexpr variables as arguments.</li>\n<li>A <strong>constexpr function</strong> can only take and return constexpr types. The key thing to know is that arguments can be accepted as constexpr, but not passed on as constexpr. Once within the function you cannot guarantee the argument values are known at compile time, even though they might be.</li>\n<li>A <strong>constexpr type/class</strong> can only have constexpr type members and must at least one constexpr constructor. All scalar types and arrays are considered constexpr.</li>\n</ul>\n<p>I’m fairly new to <strong>constexpr</strong> myself, so please do your own research, and reach out if I’m incorrect.</p>\n<h2 id=\"implementing-a-compile-time-string\">Implementing a Compile Time String</h2>\n<p>In order to perform our string parsing/creation at compile time, we need to implement a string class that satisfies the constexpr ‘contract’ for types. We must ensure that all methods we want to call after the constexpr variable construction are marked as ‘const’. The implementation is pretty self explanatory when keeping in mind the restrictions:</p>\n<pre><code class=\"language-c++\">namespace compiletime {\n\ntemplate&lt;std::size_t MaxSize = 30&gt;\nclass string\n{\n    char m_data[MaxSize] = { 0 };\n    std::size_t m_size;\npublic:\n    constexpr string() : m_data({}), m_size(0) {}\n    constexpr string(const char* str) : m_data(), m_size(0) {\n        for(int i =0; i&lt;MaxSize; ++i) {\n            m_data[m_size++] = str[i];\n        }\n    }\n    \n    constexpr char const* data() const { return m_data; }\n    constexpr operator const char*() const { return data(); } // for convenience\n    constexpr void push_back(char c) { m_data[m_size++] = c; }\n    constexpr char&amp; operator[](std::size_t i) { return m_data[i]; }\n    constexpr char const&amp; operator[](std::size_t i) const { return m_data[i]; }\n    constexpr size_t size() const { return m_size; }\n    constexpr const char* begin() const { return std::begin(m_data); }\n    constexpr const char* end() const { return std::begin(m_data) + m_size; }\n};\n\n}\n</code></pre>\n<h2 id=\"2-implementing-a-compile-time-parser\">2. Implementing a Compile Time Parser</h2>\n<p>Now that we have a string class that can used with <strong>constexpr variables</strong>, we can run <strong>constepxr</strong> functions that take this string type as arguments. Remember, in constexpr functions all arguments can be accepted as constexpr, but not passed as constexpr. Additionally, we can only use other constexpr functions and types within the function.</p>\n<p>First, let’s implement a simple function which checks if a provided character is a whitespace character:</p>\n<pre><code class=\"language-c++\">constexpr bool is_whitespace(char c) {\n    return\n        (c == &#39; &#39;) ||\n        (c == &#39;\\t&#39;) ||\n        (c == &#39;\\n&#39;) ||\n        (c == &#39;\\v&#39;) ||\n        (c == &#39;\\f&#39;) ||\n        (c == &#39;\\r&#39;);\n}\n</code></pre>\n<p>Notice the <em>constexpr</em> keyword as well as the fact that all types used (char) are constexpr-friendly. The actual ‘business logic’ is self-explanatory.</p>\n<p>Moving on and focusing on our goal, the function we want to implement takes one <strong>compiletime::string</strong>, iterates over it, and removes consecutive white-space and newlines. This can be done via a simple for-loop, with <strong>push_back</strong> calls appending the preserved characters to a new <strong>compiletime::string</strong> instance. A few predicates allow us to keep track of the parser state. Check it out:</p>\n<pre><code class=\"language-c++\">template&lt;std::size_t N&gt;\nconstexpr auto truncateWhitespace(compiletime::string&lt;N&gt; str) {\n    // Need to use non-type template for string max size\n    compiletime::string&lt;N&gt; result;\n    bool previousIsWhitespace = false; // Keep track if the previous character was whitespace\n    for(char c : str) {\n        // Skip new lines\n        if(c == &#39;\\n&#39;) {\n            continue;\n        } else if(is_whitespace(c)) {\n            // If the last character was whitespace, continue interation\n            if(previousIsWhitespace) {\n                continue;\n            }\n            // Whitespace: Set flag\n            previousIsWhitespace = true;\n        } else {\n            // Not whitespace: Reset flag\n            previousIsWhitespace = false;\n        }\n\n        result.push_back(c); // Otherwise; add character to new string\n    }\n    return result;\n}\n</code></pre>\n<p>And finally, we can provide a simple overload to allow direct string literal use:</p>\n<pre><code class=\"language-c++\">template&lt;std::size_t N&gt;\nconstexpr auto truncateWhitespace(const char (&amp;str)[N])\n{\n    compiletime::string&lt;N&gt; tmp(str); // build instance\n    return truncateWhitespace(tmp); // run function\n}\n</code></pre>\n<h2 id=\"the-spoils\">The Spoils</h2>\n<p>Now, we can actually use this construct in our code:</p>\n<pre><code class=\"language-c++\">constexpr auto query = R&quot;(\n    SELECT\n        u.id,\n        u.user_name,\n        u.ref_id,\n        u.postal_code,\n        u.email,\n        o.transaction.id\n    FROM\n        users u\n    JOIN\n        orders o ON o.user_id = u.id\n    WHERE\n        u.id=? AND u.active=?\n)&quot;;\n\nconstexpr auto trucatedQuery = truncateWhitespace(query);\nstd::cout &lt;&lt; trucatedQuery;\n// output:\n// &quot; SELECT u.id, u.user_name, u.ref_id, u.postal_code, u.email, o.transaction.id FROM users u JOIN orders o ON o.user_id = u.id WHERE u.id=? AND u.active=? &quot;\n</code></pre>\n<p>The new query length is <strong>154 characters</strong>! Which beats obviously beats the original raw literal (294) and the old “spaces before and after” mantra with traditional one-line string literals (162). And we can validate that this is actually happening at compile time with a <a href=\"https://www.google.com/search?channel=fs&amp;client=ubuntu&amp;q=static+assert\">static_assert</a>. If you are using a modern IDE/Editor with C++ integration the following statement will actually be highlighted as a failed assertion before running compilation:</p>\n<pre><code>static_assert(trucatedQuery.size() == 154);\n</code></pre>\n<p>We have succeeded and in the process gained advantages over both previous approaches:</p>\n<ul>\n<li><strong>Clearer and less cluttered code site</strong>: Freedom to use raw string literals to format queries with as much indentation as you’d like.</li>\n<li><strong>Neater, Compact Logging</strong>: New lines scattered in log files make them harder to parse and understand.</li>\n<li><strong>Less Network Bandwidth Usage</strong>: If you are using a database that directly accepts the query string, you will be sending half the bytes over the network.</li>\n<li><strong>Faster Performance</strong>: If you do any local string validation/processing/formatting, you will gain some performance.</li>\n</ul>\n<p>For the sake of it, I did a simple benchmark comparing the generated <strong>compile_time::string</strong> buffer to a <strong>const char</strong>* with the exact same literal. On my system, iterating over the provided string using a simple pointer and while loop resulted in consistently faster performance averaged over many iterations. I would be greatly concerned if it didn’t, as there is now half as many characters as before! A simple O(N) iteration operation will obviously be faster on less elements.</p>\n<p>I can see this technique providing excellent payoff for queries with many joins and deeper indentation (maybe in a lambda inside a class member function or something), sent over the network and parsed on a regular, frequent basis. It’s also just feels great, knowing you’ve reached the holy grail of performance; aka compile time operations.</p>\n<h2 id=\"limitations\">Limitations</h2>\n<p>There is one obvious limitation of this approach. Even though the ‘string’ value is shortened, we pack a buffer of the original size into the executable, padded with zeroes at the end of the string. This is because the final string size is needed as a compile time template value to construct the string class. Unfortunately, once we’re inside the <strong>truncateWhitespace</strong> function, we can’t retrieve the length to use with the string type. We also can’t make any assumptions about what the final size will be as there may not be any superfluous white-space (A simple N / 2 estimate could result in compilation failures in some cases). You could solve this this by implementing a constexpr function to calculate the final length before doing the actual truncation. Something like this:</p>\n<pre><code class=\"language-c++\">constexpr const char originalQuery[] = R&quot;(...)&quot;;\nconstexpr std::size_t slimmedSize = calculateTruncatedWhitespaceSize(originalQuery);\nconstexpr auto trucatedQuery = truncateWhitespace&lt;slimmedSize&gt;(originalQuery);\n</code></pre>\n<p>I cannot currently think of a way to do this in a way does not leverage a macro, as we can’t create function to wrap this functionality, since the arguments would not be considered constexpr inside and therefore could not be used calculate a constexpr length to be provided as a non-type template parameter to the string class. Please let me know if you can suggest a technique or trick!</p>\n<p>Another limitation is using string literals within the SQL itself. Luckily, this can be mitigated by enhancing the parser to keep track if the current point of iteration is within a string literal or not.</p>\n<h2 id=\"in-closing\">In Closing</h2>\n<p>Though the performance gains are negligible in most cases, this approach provides real benefits in clarity, logging and efficiency. You can leverage this same technique to do any kind of string pre-processing at compile time as needed.</p>\n<p><a href=\"https://gist.github.com/dgski/810ede7c4a80917c0adc99c6852fee9a\">Link to Complete Code</a></p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "constexpr",
                   "Programming",
                   "C++"
            ],
            "date_published": "2021-04-17T09:00:00-07:00",
            "date_modified": "2023-07-29T11:33:32-07:00"
        },
        {
            "id": "https://tech.davidgorski.ca/using-c17-to-create-composable-recursive-data-types/",
            "url": "https://tech.davidgorski.ca/using-c17-to-create-composable-recursive-data-types/",
            "title": "Using C++17 to Create Composable, Recursive Data Types",
            "summary": "This article presents a simple way to cleanly define nested, multi-branch type&hellip;",
            "content_html": "<p>This article presents a simple way to cleanly define nested, multi-branch type hierarchies using C++17. An endeavour which was much messier in older versions of C++. This can be altered and modified to generated pure schemas, new data types, and anything tree based. It leverages <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">std::variant</a> to cleanly express a cohesive approach to designing easily composed data structures.</p>\n<p>The final result will allow us to easily define N-Arity tree instances with clear, nested object instance declaration. For example:</p>\n<pre><code class=\"language-c++\">auto root =\n    Node(&quot;addUserRequest&quot;,\n        Sequence({\n            Node(&quot;userId&quot;, 123),\n            Node(&quot;name&quot;, &quot;Charles&quot;),\n            Node(&quot;age&quot;, 424),\n            Node(&quot;sessionInfo&quot;,\n                Sequence({\n                    Node(&quot;signOnId&quot;, &quot;f1f133112&quot;),\n                    Node(&quot;bannerId&quot;, Null())}))}));\n</code></pre>\n<h2 id=\"declaring-our-building-blocks\">Declaring Our Building Blocks</h2>\n<p>In order to get started, we need to declare the fundamental types that will allows to construct this tree system. These will include our ‘simple’, scalar data types which hold concrete data on each node: int, string, null. As well as our ‘complex’, composite data types: an ordered sequence and a <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">variant</a> representing the alternative data types each node can hold.</p>\n<pre><code class=\"language-c++\">// Forward Declaration of Tree Node\nstruct Node;\n\n// Simple \nusing Int = int;\nusing String = std::string;\nusing Null = std::monostate;\n\n// Composite\nusing Sequence = std::vector&lt;Node&gt;;\nusing Data = std::variant&lt;Int, String, Null, Sequence&gt;;\n</code></pre>\n<p>With these type declarations out of the way, our data hierarchy is starting to take shape. Some explanations:</p>\n<ul>\n<li>We forward declare our <strong>Node</strong> class, so that the Sequence type can be aware of it.</li>\n<li>We create aliases for Int, String and Null.</li>\n<li>We declare an alias for the Sequence type: a vector of Nodes. </li>\n<li>Finally, we declare the <strong>Data</strong> class. Each <strong>Node</strong> element will use a data member to hold either an Int, String, Null, or a Sequence of other Nodes.</li>\n</ul>\n<h2 id=\"the-node-class\">The Node Class</h2>\n<p>Now let’s define the Node data type: </p>\n<pre><code class=\"language-c++\">struct Node {\n    std::string m_name;\n    Data m_data;\n    explicit Node(std::string&amp;&amp; name, Data&amp;&amp; data)\n        : m_name(std::move(name)), m_data(std::move(data)) {}\n};\n</code></pre>\n<p>The above definition has two member variables:</p>\n<ul>\n<li><strong>m_name</strong>: A string used to name the node’s ‘field’.</li>\n<li><strong>m_data</strong>: The data the node is holding. Defined as a variant above.</li>\n</ul>\n<p>It also has a single explicit constructor which takes the node name and the data it holds as <a href=\"https://www.learncpp.com/cpp-tutorial/rvalue-references/\">R-value references</a>. Which means data will moved from the incoming instances if possible. If you plan to use this with variables or make copies, more constructors will have to be defined.</p>\n<p>Surprisingly, that’s it! Really. We can already build trees using the syntax demonstrated at the top of the article. Allowing us to develop nested hierarchies dynamically (but with type safety). Notice how the variant constructor accepts each type as needed to initialize the data member.</p>\n<pre><code class=\"language-c++\">auto root =\n    Node(&quot;data&quot;, Sequence({\n        Node(&quot;users&quot;, Sequence({\n            Node(&quot;david&quot;, 12322),\n            Node(&quot;charles&quot;, 2322),\n            Node(&quot;rebecca&quot;, 998)})),\n        Node(&quot;citySize&quot;, Sequence({\n            Node(&quot;nyc&quot;, 8),\n            Node(&quot;toronto&quot;, 4)}))}));\n</code></pre>\n<h2 id=\"traversing-the-structure\">Traversing The Structure</h2>\n<p>Of course, with no way to traverse the structure, it’s useless. Let’s define output stream operators so that we can ‘serialize’ the data structure to <strong>stdout</strong>.</p>\n<p>First let’s do an overload for the <strong>Null</strong> type:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Null&amp; null) {\n    stream &lt;&lt; &quot;null&quot;;\n    return stream;\n}\n</code></pre>\n<p>Very simple. Next let’s overload it for the <strong>Data</strong> (variant) type:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Data&amp; data) {\n    std::visit([&amp;](auto&amp; val) {\n        stream &lt;&lt; val;\n    }, data);\n    return stream;\n}\n</code></pre>\n<p>Here, we are using <a href=\"https://en.cppreference.com/w/cpp/utility/variant/visit\">std::visit</a> to access the variant as it’s current type. Using an auto template lambda keeps things concise. Inside, we simply apply the stream out operator to whatever is in the variant at the time (Int, Null, etc..).</p>\n<p>Next, we can overload the stream operator for the <strong>Node</strong> type. Again, this definition is simple:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Node&amp; node) {\n    std::cout\n        &lt;&lt; &quot;Node{ name=&#39;&quot; &lt;&lt; node.m_name\n        &lt;&lt; &quot;&#39; data=&quot; &lt;&lt; node.m_data &lt;&lt; &quot; }&quot;;\n    return stream;\n}\n</code></pre>\n<p>So far, so good! However, we are missing the crucial overload for <strong>Sequence</strong> (std::vector). Why is this so important? It is what enables the actual traversing to deeper levels. Look carefully:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Sequence&amp; data) {\n    std::cout &lt;&lt; &quot;Sequence[ &quot;;\n    for(const auto&amp; d : data) {\n        std::cout &lt;&lt; d &lt;&lt; &#39; &#39;;\n    }\n    std::cout &lt;&lt; &#39;]&#39;;\n    return stream;\n}\n</code></pre>\n<p>For each child Node in the sequence we use the stream out operator. And this prints out their value. What if a child node is a sequence? Well then the same operator will be called recursively as needed. Viola! We can serialize our data:</p>\n<pre><code class=\"language-c++\">auto root2 =\n    Node(&quot;test&quot;,\n        Sequence({\n            Node(&quot;name&quot;, &quot;Herbert&quot;),\n            Node(&quot;age&quot;, 55)}));\n\n// prints out:\n// Node{ name=&#39;test&#39; data=Sequence[ Node{ name=&#39;name&#39; data=Herbert } Node{ name=&#39;age&#39; data=55 } ] }\nstd::cout &lt;&lt; root2 &lt;&lt; std::endl;\n</code></pre>\n<h2 id=\"programmatically-generating-structure-segments\">Programmatically Generating Structure Segments</h2>\n<p>We have a pretty usable and extensible system already. However, what if we want to transform a vector of custom structs into a canonical <strong>Sequence</strong> in our simple tree data system? All we need to do is write a utility function that iterates over the vector to produce a sequence:</p>\n<pre><code class=\"language-c++\">template&lt;typename T, typename Func&gt;\nSequence vecToSeq(const std::vector&lt;T&gt;&amp; vec, Func func) {\n    Sequence result;\n    for(const auto&amp; v : vec) {\n        result.push_back(func(v));\n    }\n    return result;\n}\n</code></pre>\n<p>Now, we can use this function with a custom function argument to define the structure that will be appended for each data member within the vector:</p>\n<pre><code class=\"language-c++\">// Define custom type\nstruct Custom {\n    int id;\n    std::string name;\n};\n\n// Create vector\nstd::vector&lt;Custom&gt; vec = {\n    {12, &quot;Johnny&quot;}, { 344, &quot;Filber&quot;}, {999, &quot;Jennifer&quot;}\n};\n\n// Use lambda to process each item in vector and output reflecting Node data structure\nauto root3 =\n    Node(&quot;data&quot;, Sequence({\n        Node(&quot;customThings&quot;, vecToSeq(vec, [](const Custom&amp; c) {\n            return Node(&quot;custom&quot;, Sequence({\n                Node(&quot;id&quot;, c.id),\n                Node(&quot;name&quot;, c.name)})); })),\n        Node(&quot;requestId&quot;, 232324)}));\n</code></pre>\n<p>This idea can be expanded to create <strong>toTree()</strong> functions for different types. Perhaps as an exercise, one could generalize the <strong>toTree()</strong> function for all types to allow automatic conversion without direct function calls.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>As you can see, Modern C++ really improves the ability to work with composable data types using utility types such as <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">std::variant</a>. The example presented in this post, provides a simple blueprint for more specific systems. It can extended and modified to support different schema definitions, serialization, and validation. Maybe you want just types with no names? Or a schema with no concrete data? Hopefully this serves a good starting point to direct your thinking. If the curly braces bother you, you play around with template parameter packs. And if you can get by with exclusively compile time generation, maybe you can experiment with using tuples to store the sequences. Have fun!</p>\n<p><a href=\"https://gist.github.com/dgski/d00303b4a8be2d3c109d7a97d77106a3\">Link to Complete Code Example</a></p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Types",
                   "C++"
            ],
            "date_published": "2021-03-21T11:30:00-07:00",
            "date_modified": "2023-07-29T11:30:57-07:00"
        },
        {
            "id": "https://tech.davidgorski.ca/a-simple-personal-data-backup-setup-2/",
            "url": "https://tech.davidgorski.ca/a-simple-personal-data-backup-setup-2/",
            "title": "A Simple Personal Data Backup Setup",
            "summary": "Until recently, my only computer was a 2013 MacBook Air. I backed&hellip;",
            "content_html": "<p>Until recently, my only computer was a 2013 MacBook Air. I backed it up using the included Time Machine system and an external spinning disk hard drive. With the nature of it being a laptop, I didn’t have the external drive plugged in all the time, and so I set a calendar reminder to do a weekly backup because I knew I wouldn’t do it daily. It’s embarrassing to admit that even as a ‘tech professional’, there were plenty of weeks that I skipped backing up my content. I was used to the computer working all the time, I was busy and I always had some excuse to ignore the reminders. MacOS Notifications would beg me to do something:</p>\n<pre><code>It has been 3 weeks since you backed up your computer! You&#39;re asking for data loss chump!\n</code></pre>\n<p>It’s pretty obvious that in order for it to function properly, you need an automatic backup system. Otherwise, human complacency and laziness take over. Your data needs to be backed up without any input from you. Having recently undertaken an initiative to upgrade and enhance my personal technology setup, I knew I could do better.</p>\n<h2 id=\"my-overall--requirements\">My Overall  Requirements</h2>\n<ol>\n<li>Multiple copies of my data to survive hardware/software failure.</li>\n<li>Live data synchronization between my MacBook and new Linux Workstation.</li>\n<li>Snapshots available for restore.</li>\n<li>Remote copies of my data.</li>\n</ol>\n<h2 id=\"the-guiding-principle---321\">The Guiding Principle - 3,2,1</h2>\n<p>This is something that is obvious, but it really is the bare minimum, even for your personal data. The <a href=\"https://us-cert.cisa.gov/sites/default/files/publications/data_backup_options.pdf\">3,2,1 rule</a> states that you need:</p>\n<ul>\n<li><strong>3 backups</strong>: 3 total copies of your data.</li>\n<li><strong>2 local</strong>: 2 locally available copies.</li>\n<li><strong>1 remote</strong>: 1 off-site copy.</li>\n</ul>\n<p>If you satisfy these requirements, your chance of data loss is incredibly slim.</p>\n<h2 id=\"local-first\">Local First</h2>\n<p>There are many fancy approaches to create local, automatic, backup systems. Fundamentally, they lean on having a dedicated device, on-prem, holding your data. These options included:</p>\n<ul>\n<li>Purpose-built Network Attached Storage with multiple storage bays</li>\n<li>Raspberry Pi with added hardware</li>\n<li>Full Data Server</li>\n</ul>\n<p>For my needs, these were a little overkill. I wasn’t planning on using my backup as a streaming source or personal media server. I just really needed my data to be synchronized between my Macbook and my Linux Workstation. Surely there must be a simple solution for this? Luckily for me, I found <a href=\"https://syncthing.net/\">Syncthing</a>. I am very satisfied with the operational simplicity of this tool. I can just point the app to my data folder on each device, and it does the rest. The included ignore pattern functionality is also very useful in reducing the synchronization data volume amount. The nice effect of live synchronization is that the data changes are immediately reflected on the other machine.</p>\n<p>However, even though live synchronization maintains two copies of my data it is <strong>not</strong> a replacement for true backups! What if the data became corrupted on one device? The daemon would sync this corruption to the other device and I would lose content! This is what <strong>versioned backups</strong> prevent by creating snapshots of your data at certain points in time. Because my use case is simple, I am delegating versioned backups to the remote backup element. </p>\n<h2 id=\"remote-backups\">Remote Backups</h2>\n<p>With a live synchronization system working locally, I set out to add a remote backup portion to the setup. My personal stuff is not mission-critical. Maybe yours is, but mine isn’t, so a remote backup frequency of once per day was enough. Anyways, I settled on the following requirements:</p>\n<ol>\n<li><strong>Inexpensive</strong>: I don’t want to break the bank.</li>\n<li><strong>Encrypted</strong>: I’m not a privacy nut, but something still feels wrong about giving someone else carte blanche access to my data. </li>\n<li><strong>Scheduled</strong>: I would like this backup to run once a day.</li>\n<li><strong>Open-Source</strong>: This is important for two reasons: I don’t want to be locked-in and I want to be sure the app does what it says it does.</li>\n</ol>\n<p>To make a long story short; I ended up using <a href=\"https://en.wikipedia.org/wiki/Anacron\">anacron</a> and <a href=\"http://duplicity.nongnu.org/\">duplicity</a> with <a href=\"https://www.backblaze.com/b2/cloud-storage.html\">Backblaze B2</a> on my Linux Workstation.</p>\n<p><strong>Anacron</strong> allows task scheduling for devices that are not always on. So if you schedule something to run once a day, as long as your computer is on for a portion of the day; it will run.</p>\n<p><strong>Duplicity</strong> is an amazing all-in-one encryption and upload command-line backup tool. It supports full and partial backups along with support for most cloud providers. I set it up to delete the partial incremental backups after 30 days and do a full backup to save space in the long run.</p>\n<p><strong>Backblaze B2</strong> is an solid, inexpensive online storage provider. It provided all the features I needed and is compatible with duplicity out of the box.</p>\n<p>The following is templated copy of my backup script. Please note the <strong>firefox profile backup</strong> and the use of <strong>systemd-inhibit</strong> to prevent shutting down the computer while the backup is in progress:</p>\n<pre><code class=\"language-bash\"># Sync firefox profile into data folder\nrsync -a {{FIRFOX_FOLDER}} {{DATA_FOLDER}}\n\n# Push latest changes to cloud\nsystemd-inhibit --why=&quot;Daily Backup In-Progress&quot; duplicity \\\n    --verbosity 8 \\\n    {{DATA_FOLDER}} \\\n    {{CLOUD_ENPOINT_AND_API_KEY}} \\\n    --asynchronous-upload \\\n    --full-if-older-than 1M \\\n    --allow-source-mismatch \\\n    &gt;&gt; {{LOG_FILE}}\n    \necho &quot;personal backup complete ($(date))&quot; &gt;&gt; {{LOG_FILE}}\n</code></pre>\n<h2 id=\"epilogue\">Epilogue</h2>\n<p>Since setting up this system, not a single part of has failed. And maybe, it never will. But I am no longer embarrassed of my backup system and I sleep a little better at night. Please take this as a reminder to back your important stuff up. Hopefully you’ll never have to thank me!</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Linux",
                   "Backup"
            ],
            "date_published": "2021-03-13T11:29:00-08:00",
            "date_modified": "2023-07-29T11:29:47-07:00"
        },
        {
            "id": "https://tech.davidgorski.ca/concise-result-extraction-in-modern-c/",
            "url": "https://tech.davidgorski.ca/concise-result-extraction-in-modern-c/",
            "title": "Concise Result Extraction in Modern C++",
            "summary": "A popular idiom in functional programming is the use of sum types&hellip;",
            "content_html": "<p>A popular idiom in <strong>functional programming</strong> is the use of <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">sum types</a> to express results or optional values. When a function returns, it either succeeded and we get the result, or it failed and we have an error on our hands. This is a pattern in Modern C++ as well, enabled by standard library types such as <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">std::variant</a> and <a href=\"https://en.cppreference.com/w/cpp/utility/optional\">std::optional</a>. In this article we will explore how to improve the ergonomics of handling multiple results and potential error values.</p>\n<h2 id=\"the-result-type\">The ‘Result’ Type</h2>\n<p>For the purpose of this example we will define a simple ‘Result’ type: a variant that is either an ‘Error’ or a templated Type:</p>\n<pre><code class=\"language-c++\">struct Error {\n    std::string message;\n    Error(std::string _message) : message(std::move(_message)) {}\n};\ntemplate&lt;typename Type&gt;\nusing Result = std::variant&lt;Error, Type&gt;;\n</code></pre>\n<p>Now we can define functions that either succeed and return a specified type, or an Error object which holds a message:</p>\n<pre><code class=\"language-c++\">Result&lt;int&gt; getCloudInteger(Cloud&amp; cloud) {\n    if(!cloud.ok()) {\n        return Error(cloud.get_error_message());\n    }\n\n    return cloud.get_int();\n}\n</code></pre>\n<h2 id=\"getting-results\">Getting Results</h2>\n<p>This a pretty neat and clear interface, however, as with many operations we may be performing multiple operations that may success or fail. This results in a growing amount of boilerplate in the business logic code. Even when using a overloaded + operator for combining errors:</p>\n<pre><code class=\"language-c++\">auto res1 = getCloudInteger(cloud1);\nauto res2 = getCloudInteger(cloud2);\nauto res3 = getCloudInteger(cloud3);\nif(is_error(res1 &amp;&amp; is_error(res2) &amp;&amp; is_error(res3)) {\n    return get_error(res1) + get_error(res2) + get_error(res3);\n} else if(is_error(res1) &amp;&amp; is_error(res2)) {\n    return get_error(res1) + get_error(res2);\n} else if(is_error(res1) &amp;&amp; is_error(res3)) {\n    return get_error(res1) + get_error(res3);\n} else if(is_error(res1)) {\n    return get_error(res1);\n} else if(is_error(res2)) {\n    return get_error(res2);\n} else if(is_error(res3)) {\n    return get_error(res3);\n}\nauto val1 = get_ok(res1);\nauto val2 = get_ok(res2);\nauto val3 = get_ok(res3);\n</code></pre>\n<p><em>Note: is_error, get_error and get_ok are simple utility functions wrapping std::get<int> and std::holds_alternative</em></p>\n<p>As the number of results we are processing increases, more and more lines of code are to be added. Obviously, it is best to keep your business logic as clear and uncluttered from ‘implementation-level’ concerns are possible. So how can we do this better? Modern C++ gives us template parameter packs, which allows to type-safe, variable argument functions with derived return types. We will leverage them to iterate over all the results and consolidate any errors.</p>\n<h2 id=\"using-parameter-packs\">Using Parameter Packs</h2>\n<p>Parameter packs are often iterated via recursion (especially before C++17). So to start we will define two overloaded functions:</p>\n<ul>\n<li>One that takes only a distinct result type.</li>\n<li>One that takes a distinct result type and a pack argument.</li>\n</ul>\n<pre><code class=\"language-c++\">template&lt;typename Type&gt;\nauto get_all(Result&lt;Type&gt;&amp; r) -&gt; ?;\n\ntemplate&lt;typename Type, typename... Types&gt;\nauto get_all(Result&lt;Type&gt;&amp; r, Types&amp;... rest) -&gt; ?;\n</code></pre>\n<p>Now, we must determine a suitable return value interface for this operation. We can use our Result type, as it already provides a value or error paradigm. What should be the success type within the Result? Since we want this function to be used generically we don’t want a class with named member types. And using a standard library container type (such as std::vector) would add unnecessary overhead. Using a <a href=\"https://en.cppreference.com/w/cpp/utility/tuple\">std::tuple</a> with the same result order as the provided pack is the best option. This also provides compatibility with very convenient syntax sugar such as <a href=\"https://en.cppreference.com/w/cpp/utility/tuple/tie\">std::tie</a> and <a href=\"https://en.cppreference.com/w/cpp/language/structured_binding\">C++17 structure bindings</a>.</p>\n<p>Let define our single argument <strong>get_all</strong> function first:</p>\n<pre><code class=\"language-c++\">template&lt;typename Type&gt;\nauto get_all(Result&lt;Type&gt;&amp; r) -&gt; Result&lt;std::tuple&lt;Type&gt;&gt; {\n    if(is_error(r)) {\n        return get_error(r);\n    }\n    return std::make_tuple(get_ok(r));\n}\n</code></pre>\n<p>This is one is easy. The return type is simply a Result of <strong>std::tuple</strong> composed of one value: the results success type. If the result contains an error we simple return that error. Otherwise we get the value, stuff it in a tuple and stuff that tuple in a Result.</p>\n<p>The variable argument version is a little more tricky. We will have to leverage some Modern C++ to implement it properly. First we need to determine the return type for the signature. Again, the overarching type is the Result type. What is the success type? A tuple of all the success types of all the provided Result arguments. We need to extract that by feeding some tuple utility function faux calls to the <a href=\"https://en.cppreference.com/w/cpp/language/decltype\">decltype</a> specifier.</p>\n<pre><code class=\"language-c++\">template&lt;typename Type, typename... Types&gt;\nauto get_all(Result&lt;Type&gt;&amp; r, Types&amp;... rest)\n-&gt; Result&lt;decltype(std::tuple_cat(std::make_tuple(get_ok(r)), get_ok(get_all(rest...))))&gt;\n</code></pre>\n<p>Whew! Quite a bit! Although, if you’re used to C++, you will actually find that signature to be pretty clear. The <strong>decltype</strong> specifier simply “returns” the type of the expression it is provided. In this case we are saying:</p>\n<ul>\n<li><strong>decltype</strong>: Get me the type of this expression</li>\n<li><strong>std::tuple_cat</strong>: Concatenate these tuples.</li>\n<li><strong>std::make_tuple</strong>: Make a tuple with these arguments. We provide one argument: the success result of the provided first argument.</li>\n<li><strong>get_ok(get_all(res…))</strong>: Get the success result of getting the combined result of all arguments except the first one (the return type of this function call is Result of std::tuple&lt;…&gt;)</li>\n</ul>\n<p>Here is final body:</p>\n<pre><code class=\"language-c++\">template&lt;typename Type, typename... Types&gt;\nauto get_all(Result&lt;Type&gt;&amp; r, Types&amp;... rest)\n-&gt; Result&lt;decltype(std::tuple_cat(std::make_tuple(get_ok(r)), get_ok(get_all(rest...))))&gt; {\n    auto restRes = get_all(rest...);\n    if(is_error(r) &amp;&amp; is_error(restRes)) {\n        return get_error(r) + get_error(restRes);\n    } else if(is_error(r)) {\n        return get_error(r);\n    } else if(is_error(restRes)) {\n        return get_error(restRes);\n    }\n\n    return std::tuple_cat(std::make_tuple(get_ok(r)), get_ok(restRes));\n}\n</code></pre>\n<p>The function body is a lot simpler once we know what we are returning. First we recursively call get_all on the argument except the first one. Then we check their error status. If both are errors, we combine the errors using an overloaded + operator, if only the current result is an error we return that error, otherwise we return the consolidated error from the consecutive arguments. If there are no errors at all, we concatenate a tuple comprised of the first result and the tuple returned from the recursive call on the remaining arguments. Viola!</p>\n<h2 id=\"finale\">Finale</h2>\n<p>Now we can ergonomically and concisely extract results and check for errors:</p>\n<pre><code class=\"language-c++\">auto res1 = getCloudInteger(cloud1);\nauto res2 = getCloudInteger(cloud2);\nauto res3 = getCloudInteger(cloud3);\nauto aggregate_res = get_all(res1, res2, res3);\nif(is_error(aggregate_res)) {\n    return get_error(aggregate_res);\n}\nauto [val1, val2, val3] = get_ok(aggregate_res);\n</code></pre>\n<p>This can be further refined and modified to suit your needs. Perhaps you can use an R-Value Reference argument signature and eliminate the need for the temporary Result variables:</p>\n<pre><code class=\"language-c++\">auto aggregate_res = get_all(\n    getCloudInteger(cloud1), getCloudInteger(cloud2), getCloudInteger(cloud3));\nif(is_error(aggregate_res)) {\n    return get_error(aggregate_res);\n}\nauto [val1, val2, val3] = get_ok(aggregate_res);\n</code></pre>\n<p>Or, if you prefer exception-based error handling but are dealing with a functional interface, you can simply throw exceptions within a get_all wrapper, eliminating even more boilerplate:</p>\n<pre><code class=\"language-c++\">auto [val1, val2, val3] = get_all_vals(\n    getCloudInteger(cloud1), getCloudInteger(cloud2), getCloudInteger(cloud3)\n</code></pre>\n<p>Modern C++ Parameter Packs and error handling allow for cleaner call sites around your business logic. Writing a simple helper function like this is not difficult and can reduce the number of lines of code while allowing you to express your ideas and control flow more cleanly. This is especially useful for <strong>std::async and std::future</strong> and other libraries like it.</p>\n<p><a href=\"https://gist.github.com/dgski/df5d7dcfc77031f79675f3b50565a051\">Link to Complete Code Example</a></p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Functional Programming",
                   "C++"
            ],
            "date_published": "2021-03-06T11:28:00-08:00",
            "date_modified": "2023-07-29T11:28:24-07:00"
        },
        {
            "id": "https://tech.davidgorski.ca/five-web-project-lessons/",
            "url": "https://tech.davidgorski.ca/five-web-project-lessons/",
            "title": "Five Web Project Lessons",
            "summary": "Last month, I finally launched my collaborative map-based urban planning web application:&hellip;",
            "content_html": "<p>Last month, I finally launched my collaborative map-based urban planning web application: <a href=\"https://plantogether.city\">Plan Together</a>. It was a lot of work, but I must say I am proud of the result; it is my most feature-complete project to date. It’s quite an experience having to do 100% of the work for product development, system architecture design, programming, and user interface/experience design. It definitely increases one’s respect for the work of their co-workers in different departments. I highly recommend it.</p>\n<p>Here are some lessons I learned along the way from a software developer’s point of view:</p>\n<h2 id=\"1-consider-http-request-overhead\">1. Consider HTTP request Overhead</h2>\n<p>As a C++ Back-End Web Service Developer I work mainly with a in-house binary transmission protocol which composes and parses the bare minimum of bytes per message. Sending data which is not directly relevant is considered an affront. During the initial design and prototype phase, my driving philosophy was to send many small requests, retrieving only what was immediately necessary. However, during trials, I had to confront the fact that each individual HTTP request is padded with a rather large amount of overhead due to Headers. I was forced to reduce the number of requests and increase their size, which is the logical approach from a web developer’s point of view. Lesson learned.</p>\n<h2 id=\"2-remember-database-access-overhead\">2. Remember Database Access Overhead</h2>\n<p>Theoretically, this is an obvious one. But nothing hits you as hard as actually having to design data shape and retrieval processes yourself. Just as with HTTP requests, my initial approach had numerous small SELECTs, in an effort preventing retrieval of data that might not be needed. Originally, one SELECT would retrieve a collection of ids (defining relevant records), and other SELECTs would retrieve other data columns as needed. I was being too clever. Maybe my approach would work if database access was free, but that is far from the case. It became very clear; it is better to perform wider queries, selecting more information than needed. Go in, grab a chunk of mostly relevant data, and exit. Finally, cache it. Disturbing the database should be your last resort.</p>\n<h2 id=\"3-good-deployment-pipelines-are-hard-to-implement-but-worth-it\">3. Good deployment pipelines are hard to implement (But Worth It)</h2>\n<p>As a developer at a large company, automated build setup, production deployment and configuration are parts of the software world that I don’t need to touch. I just focus on my teams specific modules, write code that fulfills requirements, and follow existing guidelines. After code is reviewed and tested, it is out of my hands. I do not directly take the code and make it do live work for users. Since I was the only person working on <a href=\"https://plantogether.city\">Plan Together</a>, I obviously had to do it myself. Sometimes, configuration is pure hell. Figuring out the details of how GitHub Actions are triggered, which cloud platforms are best for your Front-End and Back-End, and how to best deploy your application takes a while and feels very unproductive. It was hard to let go of the mindset that if I was not working on the code or the concept, I was wasting time. Now, I am happy I spent that time. I can easily deploy changes just by merging feature-branches into the production branch and all deployment is automatic.</p>\n<h2 id=\"4-most-external-apis-are-easy-to-integrate\">4. Most External APIs are easy to integrate</h2>\n<p>We are really living in a Golden Age of integration. Adding external features to your product is easier than ever. Finally writing something myself proved this directly. The <a href=\"https://plantogether.city\">Plan Together</a> application automatically posts certain Map Items to twitter, mentioning relevant accounts: <a href=\"https://twitter.com/cityofcalgary/status/1228341986924679168\">City Of Calgary Tweet Example</a>. I was surprised how easy this was to implement. I applied for a Twitter Developer Account, integrated the relevant library into the code-base and was easily able to start tweeting map images.</p>\n<h2 id=\"5-ruthlessly-prioritize-features-and-focus-on-releasing-anything\">5. Ruthlessly Prioritize Features and Focus on Releasing Anything</h2>\n<p>It becomes very easy to delay a release. Feature and scope creep are real. And especially since you are the only person working on this project, your ego becomes tied up in it. You want it to be good enough, you start daydreaming of a big launch. So you keep adding more and more to the product. I caught myself doing this more than once during development. Now, after the initial release, I realized how important it is to get something out there into the real world. Not only do you get real feedback, but your self-pressure is taken off your shoulders. I have actually been able to accelerate development since release and added a handful new features: <a href=\"https://blog.plantogether.city/post/march-platform-updates/\">9 New Features Added to Plan Together Since Launch</a></p>\n<p>Thanks for reading my article! Feel free to checkout <a href=\"https://plantogether.city\">Plan Together</a>, or email me with comments/questions at <a href=\"mailto:dg@davidgorski.ca\">dg@davidgorski.ca</a>.</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Webapp",
                   "Project",
                   "Programming"
            ],
            "date_published": "2020-03-15T11:28:00-07:00",
            "date_modified": "2023-07-29T11:29:15-07:00"
        },
        {
            "id": "https://tech.davidgorski.ca/back-end-development-basics/",
            "url": "https://tech.davidgorski.ca/back-end-development-basics/",
            "title": "Back-End Development Basics",
            "summary": "Know your Data It is most important for a back-end developer to&hellip;",
            "content_html": "<h2 id=\"know-your-data\">Know your Data</h2>\n<p>It is most important for a back-end developer to understand the characteristics of the Data their software will interact with. This includes both data inflows and data outflows. Questions such as the following need to be asked:</p>\n<ul>\n<li>How much data is incoming?</li>\n<li>What is the shape/type of the data?</li>\n<li>How should this data be processed?</li>\n<li>Where is this data needed or useful?</li>\n<li>What is the corresponding response to this type of data?</li>\n<li>How soon is a response needed?</li>\n</ul>\n<p>After careful deliberation and analysis, implementation details will naturally emerge regarding load balancing, API design, data structures, micro-service division of labor, parallelization of processing, replication, stream-publishing, table design, caching, relational vs key-value etc. </p>\n<p>The data is the canonical source for developing robust back-end endpoints and services. This is relevant from the high-level architectural decisions all the way to direct coding.</p>\n<p>For example, a service which handles low data volume, with simply query parameters, with low amounts of processing (CRUD), with no real-time requirements in response time, can and should be incredibly simple. There is no reason to over-complicate things. A basic load-balancer paired with a simple web-app and simple db is good enough (with regular backups of course).</p>\n<p>Conversely, a service which handles billions of requests a day, with high levels of processing, and many orthogonal services waiting for the data will need specialized streams/queues, parallel processing, advanced backup systems, specialized data structures with aggressive caching.</p>\n<h2 id=\"architecture\">Architecture</h2>\n<h3 id=\"system-scaling\">System scaling</h3>\n<p>For high-performance, high-throughput systems, it is important to get the basics right. Paying attention to the data you are dealing with, and analyzing the space and time complexities of your algorithms is crucial.</p>\n<ul>\n<li>Use appropriate algorithms and data structures</li>\n<li>Lift load on resources as soon as possible. (Early returns, forwarding requests to relevant module, etc)</li>\n<li>Check for and handle errors as early as possible. Prevent propagation of errors.</li>\n<li>Find a good point of modularity (monolith vs microservices)</li>\n<li>As simple as possible data distribution and replication pipeline.</li>\n<li>Determine level of Data normalization (optimize for speed vs optimize for reduction of redundancy)</li>\n</ul>\n<h3 id=\"maintainability\">Maintainability</h3>\n<p>For large systems, it is important to build services for maintainability. This includes using:</p>\n<ul>\n<li>Clean, clear code</li>\n<li>Simple abstractions</li>\n<li>Microservices for separation of concern</li>\n<li>Well-defined, versioned APIS, as well as organization process for creating new endpoints</li>\n<li>Re-use what you can</li>\n<li>Cherry-pick suitable design patterns (SOLID, functional, etc…), do not force</li>\n</ul>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "data",
                   "backend",
                   "Architecture"
            ],
            "date_published": "2020-01-25T09:00:00-08:00",
            "date_modified": "2023-07-29T11:25:31-07:00"
        },
        {
            "id": "https://tech.davidgorski.ca/the-fixed-point-combinator-function/",
            "url": "https://tech.davidgorski.ca/the-fixed-point-combinator-function/",
            "title": "The Fixed-Point Combinator Function",
            "summary": "The goal of this article is to explain the purpose and functionality&hellip;",
            "content_html": "<p>The goal of this article is to explain the purpose and functionality of <strong>fixed-point combinator functions</strong>. I had a hard time following along with other articles on this topic so I wrote this as a learning exercise. We’ll be using the <strong>Scheme</strong> language.</p>\n<p>So what is a <strong>fixed-point combinator</strong>? It is a function which given a function as an argument, returns a fixed point of that function. Let’s demonstrate why this could be useful.</p>\n<p>First, let start by defining a factorial function recursively:</p>\n<pre><code>(define fact \n  (lambda (n)\n    (if (zero? n) 1 (* n (fact (- n 1))))))\n</code></pre>\n<p>Theoretically, if our language suddenly loses recursion as a feature we run into a big problem; we can’t refer to a function that is not bound! There is no ‘self’ keyword inside a anonymous function (which would let us reference the function from within) and therefore the function will no longer be valid:</p>\n<pre><code>(lambda (n)\n  (if (zero? n) 1 (* n (??? (- n 1)))))\n</code></pre>\n<p>To clarify, the function is actually valid, but only for an input of <strong>0</strong>:</p>\n<pre><code>; 0 -&gt; 1\n\n((lambda (n)\n  (if (zero? n) 1 (* n (??? (- n 1))))) 0)\n</code></pre>\n<p>But if we try with any other value, it will fail:</p>\n<pre><code>; 1 -&gt; error: unbound symbol (???)\n\n((lambda (n)\n  (if (zero? n) 1 (* n (??? (- n 1))))) 1)\n</code></pre>\n<p>An input of <strong>1</strong> does not fulfill the first condition <strong>(zero?)</strong>, so it attempts to call <strong>???</strong> with <strong>(- n 1)</strong> as it’s argument. <strong>???</strong> is a symbol not bound to anything so an error is raised. However, we do know that for the current call the expression <strong>(- n 1)</strong> is equal to <strong>0</strong>, since <strong>n</strong> is bound to <strong>1</strong>. We know this function works for zero, so we know we can simply substitute it in for <strong>???</strong>. Now we have a function that works for two inputs: 0 and 1:</p>\n<pre><code>((lambda (n)\n  (if (zero? n)\n      1\n      (* n ((lambda (n)\n              (if (zero? n) 1 (* n (??? (- n 1))))) (- n 1))))) 1)\n</code></pre>\n<p>Using the former logic we can continue this process, replacing <strong>???</strong> with our ‘factorial’ lambda; creating a function that can work with another successive input. This could get tedious, so let’s write a function that does that for us.\nIt will consume a function (f) and return the factorial function, replacing <strong>???</strong> with the input (f). If we provide this new function a factorial function it will have a factorial function to run if the term is not <strong>0</strong>.</p>\n<pre><code>(define fact-gen\n  (lambda (f)\n    (lambda (n)\n      (if (zero? n) 1 (* n (f (- n 1)))))))\n</code></pre>\n<p>By itself, the return value is our <strong>fact0</strong> function, which we used unbound earlier, Since an input of 0 doesnt call the <strong>f</strong> function, we can pass anything we’d like.</p>\n<pre><code>(define fact0 (fact-gen &#39;trash))\n -&gt; (lambda (next)\n      (lambda (n)\n        (if (zero? n) 1 (* n (&#39;trash (- n 1))))))\n\n(fact0 0) -&gt; 1\n</code></pre>\n<p>However, due to the conditional statement, if input is greater than <strong>0</strong>, the argument will be called, and that’s simply impossible as it is currently is just  a <strong>‘trash</strong> symbol.</p>\n<pre><code>(fact0 1) -&gt; ERROR\n</code></pre>\n<p>We need to supply a function that will give us the factorial of <strong>(- 1 1)</strong>. Wait a second… That expression equals <strong>0</strong>… We already have a function that gives us the factorial of <strong>0</strong>… Let’s run <strong>fact-gen</strong> and pass it <strong>fact0</strong>.</p>\n<pre><code>(define fact&lt;=1 (fact-gen fact0))\n</code></pre>\n<p>Using this newly generated function, we can find the factorial of any number equal or less than one. Can we continue? In fact, yes!</p>\n<pre><code>(define fact&lt;=2 (fact-gen fact&lt;=1))\n</code></pre>\n<p>Now the next step is clear. We need to supply the consecutive factorial function to the previous factorial function n + 1 times (starting at 0). How can we continually feed the <strong>fact-gen</strong> function these next factorial functions? Turns out that a combinator function can do that for us:</p>\n<pre><code>(define combinator\n  (lambda (func)\n\n    (define make-step\n      (lambda (next-step)\n        (lambda (arg)\n          ((func (next-step next-step)) arg))))\n\n    (lambda (arg)\n      ((func (make-step make-step)) arg))))\n</code></pre>\n<p>Notice that the returned lambda at the end of <strong>combinator</strong> function and the returned lambda for the locally scoped function <strong>make-step</strong>, are exactly the same. This is crucial. That means that when the generated factorial function needs the next factorial function, it simply inserts itself again. Let’s walk through this. Running <strong>(combinator fact-gen)</strong> will return:</p>\n<pre><code>; figure-1\n(lambda (arg)\n  ((fact-gen (make-step make-step)) arg))\n</code></pre>\n<p>When this function is called with any argument it will first resolve the expression <strong>(make-step make-step)</strong>. This function call will return the following:</p>\n<pre><code>; figure-2\n(lambda (arg)\n  ((fact-gen (make-step make-step)) arg))\n</code></pre>\n<p>Does this look familiar? Its the same as before! This is the fixed point. As seen in <strong>figure-1</strong>, this lambda (figure-2) will serve as the argument for the <strong>(fact-gen figure-2)</strong> function call, which returns:</p>\n<pre><code>; figure-3\n(lambda (n)\n      (if (zero? n) 1 (* n (figure-2 (- n 1)))))\n</code></pre>\n<p>Let’s call it with the argument of number ‘1’: <strong>(figure-3 1)</strong>. Since 1 is not <strong>zero?</strong> the control flow will evaluate the next expression: <em><em>(</em> 1 (figure-2 (- 1 1)))</em>*. Which includes the function call <strong>(figure-2 (- 1 1))</strong>. This will return the following:</p>\n<pre><code>((fact-gen (make-step make-step)) arg)\n</code></pre>\n<p><strong>(make-step make-step)</strong> will again return:</p>\n<pre><code>; figure-4\n(lambda (arg)\n  ((fact-gen (make-step make-step)) arg))\n</code></pre>\n<p>and the whole <strong>figure-2</strong> call will evaluate to:</p>\n<pre><code>; figure-5\n(lambda (n)\n      (if (zero? n) 1 (* n (figure-4 (- n 1)))))\n</code></pre>\n<p>Just to clarify, we are currently evaluating <em><em>(</em> 1 (figure-2 (- 1 1)))</em>*. <strong>n</strong> is bound to <strong>0</strong> in <strong>figure-5</strong>, so the <strong>if</strong> expression returns 1. Therefore everything resolves to:</p>\n<pre><code>(* 1 1) -&gt; 1\n</code></pre>\n<p>And that’s pretty much it. We can simplify the whole thing by eliminating our locale definition of <strong>make-step</strong> and replacing our readable variables with single letters:</p>\n<pre><code>(define Z\n  (lambda (f)\n      (lambda (a)\n        ((f ((lambda (y) (lambda (a) ((f (y y)) a)))\n             (lambda (y) (lambda (a) ((f (y y)) a))))) a))))\n</code></pre>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Scheme",
                   "Functional Programming"
            ],
            "date_published": "2019-05-12T11:27:00-07:00",
            "date_modified": "2023-07-29T11:27:41-07:00"
        }
    ]
}
