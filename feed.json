{
    "version": "https://jsonfeed.org/version/1",
    "title": "Tech @ DG",
    "description": "",
    "home_page_url": "https://tech.davidgorski.ca",
    "feed_url": "https://tech.davidgorski.ca/feed.json",
    "user_comment": "",
    "author": {
        "name": "David Gorski"
    },
    "items": [
        {
            "id": "https://tech.davidgorski.ca/why-i-still-find-programming-inspiring-7-years-later/",
            "url": "https://tech.davidgorski.ca/why-i-still-find-programming-inspiring-7-years-later/",
            "title": "Why I Still Find Programming Inspiring, 8 Years Later",
            "summary": "I’ve been programming for 8 years now. While there have been ups&hellip;",
            "content_html": "<p>I’ve been programming for 8 years now. While there have been ups and downs, I’ve recently had a chance to reflect on my dual choice in career and hobby. It still means a lot to me.</p>\n<p>As an act of creative expression, it is truly unique. Programming is the act of creating <em>moving poetry</em>. Programs are not merely words at rest, they define and prescribe actions that will take place and interact with each other. As a form of writing it is also much more dynamic; as code is more likely to be updated than articles, books or blogs.</p>\n<p>It also includes a foil to the creativity. There is a requirement for the application of the muse to be logically consistency. Code isn’t just free-for-all modern art. You have real rules to play within; providing a grounded world to inhabit. This ‘grounding’ provides objectivity to the sport and allows comparison and competition between pieces.</p>\n<p>Also, programming is hilariously useful. It enables our modern world to run. To re-quote for the millionth time: <em>Software is eating the world.</em> And it is not for nothing: automation frees humanity of mundane, repeat tasks while unlocking a new form of leverage. Write once; run infinity times. This is especially mind-boggling when realizing the reduced capital requirements in the face of traditional industries.</p>\n<p>It can be easy to become jaded towards one career and one’s craft. The fun, art, hacking is often overshadowed by business requirements and politics. I get that. But, when you pause and think, it is truly magical we get to make money with intellectual self-reflection.</p>\n<p>I realized that this is precisely the dark side of it all; the self is a little too involved in the job. It touches the ego, the intellect and the creative identity. For such a well-compensated and flexible job, the number of depressed and burnt-out developers is quite high.</p>\n<p>It has been prognosticated many times that the end of programming is nigh; thanks to the development of new no-code tools. And maybe this time, with AI and large language models, that will be true. But that doesn’t change that for a brief moment in history, humans could talk to machines using their native language. And that’s more than kinda neat.</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
            ],
            "date_published": "2024-03-13T14:31:52-04:00",
            "date_modified": "2024-03-13T14:46:39-04:00"
        },
        {
            "id": "https://tech.davidgorski.ca/introduction-to-low-latency-programming-external-processing/",
            "url": "https://tech.davidgorski.ca/introduction-to-low-latency-programming-external-processing/",
            "title": "Introduction To Low Latency Programming: External Processing",
            "summary": "This post originally appears as a chapter in my new book: ‘Introduction&hellip;",
            "content_html": "<p><em>This post originally appears as a chapter in my new book: ‘Introduction To Low Latency Programming’, a short and approachable entry into the subject. <a href=\"https://a.co/d/0U6KOfb\">Available now for purchase on Amazon</a>.</em></p>\n<p>After heavily scrutinizing your program scope you should be left with some functional requirements that are absolutely mandatory, as well as some latency goals you are aiming for. From here, you can start thinking about which pieces of the program could potentially be extracted from the main execution path, to keep it as fast as possible. For our purposes, the <em>main execution path or task</em> is process, system or function that is measured by our defined metrics. Here are some questions you can ask yourself to prepare for this process:</p>\n<ul>\n<li>What is known before the program even runs?</li>\n<li>Can we use this information to ‘do’ some steps before runtime?</li>\n<li>Does any part of the runtime process need to be done ‘real time’?</li>\n<li>Can any of the runtime steps be isolated into a task that can be packaged into a cohesive unit?</li>\n<li>What is the potential cost of communicating with the main task?</li>\n</ul>\n<h2 id=\"pre-processing\">Pre-processing</h2>\n<p>When we are discussing ‘low latency’ we are almost always referring to latency at runtime. Therefore, if we can remove segments of the program functionality and execute them before we enter our low latency execution; we can effectively get them done for ‘free’.</p>\n<p>If you have a lot of information that is used as an input to the runtime computation available to you before the process is even started, you can attempt to perform some parts of the computation even before the program is run. The following subsections discuss some common approaches.</p>\n<h3 id=\"configurationinput-files--loading-on-start-up\">Configuration/Input Files + Loading On Start Up</h3>\n<p>One approach is to generate configuration/input files and supply them to the process at startup. This is very simple from an operation and code perspective. You can create a separate process, or group of processes, that reads from any number of inputs, performs necessary computations and then outputs the results into a file. This file is then read by the low-latency process at start up. Steps:</p>\n<ol>\n<li>Run external process that completes and generates a file.</li>\n<li>Start the low-latency task/runtime, supplying the file as input.</li>\n</ol>\n<p>Additionally, if you don’t need the preparation functionality to be uncoupled from the process, you can have the main process itself do this computation before it enters the low-latency execution phase. This is simple and has an even lower operational overhead as the preparation code lives in the same code ‘space’ as the low-latency code. Warming process steps:</p>\n<ol>\n<li>Warming up: read various database tables into memory, calculate some weights, etc.</li>\n<li>Enter low-latency runtime loop.</li>\n</ol>\n<h3 id=\"compile-time-processing\">Compile Time Processing</h3>\n<p>Another option is ‘hard-coding’ computation into the executable with compile-time programming options: code generation, templates, and ‘constexpr’ functions, methods and variables. These approaches can help reduce instruction count/cost and branching; both key goals of low latency programming (discussed later in the book). While they can provide ‘the fastest’ runtime, they may also be difficult to use in comparison to runtime options. However, they do allow us to squeeze out maximum performance and are often worth pursuing. They are ‘external’ in the sense that they don’t occur during our low-latency runtime operations, because they don’t occur at all. The removal decision is in some sense a type of processing.</p>\n<h4 id=\"code-generation\">Code Generation</h4>\n<p>Code generation takes on many forms. It is the creation of programs that generate code as output. The inputs provided to the code generation program will determine the end functionality included in the final code. This allows us remove ‘work’ and decision-making out of the final runtime and perform these ‘steps’ before or at compile time. The code generator does not have to meet your low latency goals itself, as it is the final runtime process performance that actually matters. Here is a sample code generation script execution:</p>\n<pre><code class=\"language-bash\">python3 generateCode.py --input inputs.json --output output.cpp\n</code></pre>\n<p>The <strong>inputs.json</strong> file will dictate what will be included in the final code within the <strong>output.cpp</strong> file.</p>\n<h4 id=\"compile-flags-and-templates\">Compile Flags and Templates</h4>\n<p>You can build programs that use C++ template arguments for specialization: both for types and values. Then, at compile time you can supply flags that will select the correct specialization. Everything unrelated to your supplied options will not be included in the runtime. The following is a super simple example:</p>\n<pre><code class=\"language-c++\">#ifdef BUYER\n  using OrderManager = BuyOrderManager;\n#else\n  using OrderManager = SellOrderManager;\n#endif\nSystem&lt;OrderManager&gt; orderManager;\n</code></pre>\n<p>The <code>System</code> class takes <code>OrderManager</code> as a template argument and passes it down to other child members. The value of this template argument changes its runtime behavior at compile time; effectively doing the ‘decision-making’ before the program is executed. Of course, we need to pass in the <code>BUYER</code> flag during compilation:</p>\n<pre><code class=\"language-bash\">g++ -o trade_app trade_app.cpp -DBUYER\n</code></pre>\n<h4 id=\"leveraging-constexpr-utilities\">Leveraging ‘constexpr’ Utilities</h4>\n<p>Modern C++ (since C++11) has given us <code>constexpr</code> which allows marking variables, functions, classes and methods with a hint that expressions can be resolved at compile time. Here are the ‘rules’:</p>\n<ul>\n<li>A constexpr variable must be initialized as a constexpr type with a constepxr function. These must be constructed/called with either literals or other constexpr variables as arguments.</li>\n<li>A constexpr function can only take and return constexpr types. The key thing to know is that arguments can be accepted as constexpr, but not passed on as constexpr. Once within the function you cannot guarantee the argument values are known at compile time, even though they might be.</li>\n<li>A constexpr type/class can only have constexpr type members and must at least one constexpr constructor. All scalar types and arrays are considered constexpr.</li>\n</ul>\n<p>Even with this constrained set of functionality, we can do some pretty fancy stuff. All the way from specializing function bodies using template parameters to parsing JSON at compile time. The rabbit hole goes deep. In a way it is a form of ‘code generation’ included in C++. Other languages have other forms of compile time pre-processing.</p>\n<p>Using <code>constexpr if</code> and a template argument to specialize function body:</p>\n<pre><code class=\"language-c++\">\ntemplate&lt;bool DoOne&gt;\nvoid process() {\n  if constexpr (DoOne) {\n    // ...\n  } else {\n    // ...\n  }\n}\n</code></pre>\n<p>Calculating hash at compile time:</p>\n<pre><code class=\"language-c++\">template&lt;size_t Length&gt;\nconstexpr size_t hash(const char(&amp;str)[Length]) {\n  size_t result = 0;\n  for (size_t i = 0; i &lt; (Length - 1); i++) {\n    result ^= str[i] &lt;&lt; (i % 8);\n  }\n  return result;\n}\n\n// ...\nconstexpr auto hashValue = hash(&quot;Hello, World!&quot;);\n</code></pre>\n<p>Every subsequent version of C++ has significantly boosted the functionality provided by constexpr. Make as much of your code and static data ‘constexpr’ as possible. I have to note something here; The benefit of constexpr is not just the reduction of instructions. You could do that with your own precalculation and storage of static data in an executable written in assembly. This, however, would be incredibly tedious. <code>constexpr</code> is powerful because it treats compile-time resolved data just as it does code; something that can be understood by the programmer and to be updated as objectives/requirements evolve. That is the true power of the constexpr ‘contract’.</p>\n<h2 id=\"external-parallel-processing\">External Parallel Processing</h2>\n<p>Sometimes information is not known before runtime; it requires input from data received during runtime or is updated throughout the day from external sources or computation. This section will discuss a few ways that external processing can be done when the program is already running.</p>\n<h3 id=\"separate-process\">Separate Process</h3>\n<p>Our first option is to have external processes that perform the extracted tasks. This is usually the case for data that does not require inputs from the process itself. Perhaps this is the result of some grid computing batch result or incoming network data. In any case, after the external process is done, it needs a way to pass this data into the already-running main process. The selection of communication method is dependent on data size and the latency requirement. If this is a change that occurs a few times a day we’d use one approach as opposed to a message that is sent every 10 microseconds.</p>\n<p>If this communication rarely happens we can choose a simple method with a low operational overhead such as writing the results to a file and signalling the already running process to read the file. This would be useful for something like a configuration file change or perhaps loading a new machine learning model weights. <strong>SIGUSR1</strong> and <strong>SIGUSR2</strong> are the signals reserved for the program’s own use. The safest way to do this is to register simple flag-setting handler functions at startup which will be called when the signal is received. Handler complexity itself should be kept to a minimum:</p>\n<pre><code class=\"language-c++\">#include &lt;signal.h&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\n// Global variable to indicate if a reload is needed\nbool performReload = false;\n\n// Signal handler\nvoid handler(int) {\n  performReload = true;\n}\n\nint main() {\n  // Register signal handler\n  signal(SIGUSR1, handler);\n\n  // Enter main loop\n  while(true) {\n    if (performReload) {\n      std::cout &lt;&lt; &quot;Reloading configuration...&quot; &lt;&lt; std::endl;\n      performReload = false;\n    }\n    // Actual work\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n  }\n  return 0;\n}\n</code></pre>\n<p>However, if this communication stream is almost constant, we would have to select a different option. For low latency programs, the common choice is using shared memory with atomic access operations. This leverages operating system constructs that allow two different processes to access the same block of memory; something forbidden by default. Atomic operations are instructions which guarantee atomic accesses and updates of memory. In simpler terms; you are able to assume that no other thread/process is able to read/write to the variable while you are reading or writing to it. The other accessor will either get the old version or the new version depending on instruction scheduling and/or atomic sequencing level chosen. Without using atomic operations you might read memory with an in-between state. There are multiple levels of guarantee:</p>\n<ul>\n<li>Relaxed</li>\n<li>Consume</li>\n<li>Release</li>\n<li>Acquire</li>\n<li>Acquire/Release</li>\n<li>Sequentially Consistent</li>\n</ul>\n<p>You can read more about them by reading the documentation of <code>std::atomic::memory_order</code>. In general, as you move down the list, the guarantees get stronger and stronger about how memory is to be written/read as other threads/processes do the same. Really think about how your memory will be accessed and what the reader/writer really needs to be guaranteed in order to fulfill their objectives. Keep in mind: stronger guarantees cost more; time-wise.</p>\n<p>Once you have two processes accessing the same memory space, you can design data structures that enable communication between the two. The favorite choice for low latency applications is a ring buffer implemented as a contiguous array in memory. The API/design differs based on different access scenarios; mainly affected by the number of simultaneous consumers or producers. A single producer/consumer queue is very simple to implement. The following example is not optimized, but captures the general idea. Try to walk through how the reader and writer each would access the memory with atomic and non-atomic instructions. Think about how the access indices interact and why they begin with an offset from one another. After reading about <code>std::atomic::memory_order</code>, which guarantees do we need for which operations? By default, they use <code>memory_order_seq_cst</code>; with the strictest guarantees.</p>\n<p>A simple single producer, single consumer wait-free queue:</p>\n<pre><code class=\"language-c++\">template&lt;typename T, size_t N&gt;\nclass WaitFreeQueue {\n  T _data[N];\n  std::atomic&lt;size_t&gt; _readSequence = 0;\n  std::atomic&lt;size_t&gt; _writeSequence = 1;\npublic:\n  WaitFreeQueue() = default;\n\n  bool tryWrite(T value) {\n    const auto nextWriteIndex = _writeSequence % N;\n    const auto currentReadIndex = _readSequence % N;\n    const bool noRoomLeft = (nextWriteIndex == currentReadIndex);\n    if (noRoomLeft) {\n      return false;\n    }\n    _data[nextWriteIndex] = std::move(value);\n    _writeSequence.store(nextWriteIndex + 1);\n    return true;\n  }\n\n  T* tryRead() {\n    const auto nextReadIndex = (_readSequence + 1) % N;\n    const auto nextWriteIndex = _writeSequence % N;\n    const bool noNewData = (nextReadIndex == nextWriteIndex);\n    if (noNewData) {\n      return nullptr;\n    }\n    _readSequence.store(nextReadIndex);\n    return &amp;_data[nextReadIndex];\n  }\n};\n</code></pre>\n<p>To use this across processes, you would create a shared memory segment and construct this queue in the memory space in <strong>one</strong> process using placement new: <code>new (shared_memory_ptr) WaitFreeQueue&lt;int, 100&gt;();</code>. The other processes would simply interpret the shared memory pointer as the queue and use it.</p>\n<p>If you try to extract the address pointer out of one process and use the raw value in another; your second process would be crashed by the operating system. It would be trying access memory outside its virtual memory space and this is forbidden.</p>\n<h3 id=\"separate-thread\">Separate Thread</h3>\n<p>Sometimes this external computation requires data that the main process provides during runtime. In that case it might be more ergonomic to perform the computation in the same process but on a different thread. For the most part the performance distinction between processes and threads can be blurry. For many operating systems, they operate in the same way once you attach to the same shared memory region. The decision would be more so about the level of coupling you want between the foreground and background task runners. In this section we will be discussing a background task that is: 1. Critical to the runtime of the foreground task. 2. In constant back-and-forth communication with the foreground task. Therefore, it is probably better to use a thread for this job rather than a separate process. This can be summarized into the following:</p>\n<ul>\n<li>Use a process if you want the background task to run uncoupled with the foreground task. I.e. you are okay with each task to run separately.</li>\n<li>Use a thread if you want the background task to be coupled with the foreground task. I.e. you need both tasks to be running constantly.</li>\n</ul>\n<p>One thing to note that is applicable to both separate thread and separate process asynchronous tasks: <strong>The communication mechanism overhead must be less costly to the foreground task then just performing the task itself.</strong> Otherwise, what is the point of doing it in the background?</p>\n<p>Just as with separate processes, using a separate thread to perform tasks will ideally be coordinated using atomic variables as they can allow for ‘wait-free’ operations. You will not be waiting for a non-deterministic amount of time/CPU clock cycles. The same data structures/instructions you use with a separate process can be used across threads.</p>\n<h2 id=\"chapter-summary\">Chapter Summary</h2>\n<ul>\n<li>You can remove expensive computation outside your program to help reduce latency.</li>\n<li>These computations can be done at compile time, at start-up, or in an external thread or process.</li>\n<li>If the processing is done externally, ensure you select the best communication option for the job.</li>\n</ul>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Low Latency",
                   "C++"
            ],
            "date_published": "2024-03-11T11:39:16-04:00",
            "date_modified": "2024-03-11T11:39:16-04:00"
        },
        {
            "id": "https://tech.davidgorski.ca/introduction-to-low-latency-programming-understand-storage/",
            "url": "https://tech.davidgorski.ca/introduction-to-low-latency-programming-understand-storage/",
            "title": "Introduction To Low Latency Programming: Understand Storage",
            "summary": "This post originally appears as a chapter in my new book: ‘Introduction&hellip;",
            "content_html": "<p><em>This post originally appears as a chapter in my new book: ‘Introduction To Low Latency Programming’, a short and approachable entry into the subject. <a href=\"https://a.co/d/0U6KOfb\">Available now for purchase on Amazon</a>.</em></p>\n<p>So far we have focused on the computation aspect of low latency programming. However, optimized data access plays a huge role in this domain. No process is computation only, it needs data to compute on. This chapter will discuss the key ideas to keep in mind for the optimization of reading and writing from storage.</p>\n<h2 id=\"be-aware-storage-performance-and-access-costs\">Be Aware Storage Performance And Access Costs</h2>\n<p>I am using the word ‘storage’ quite broadly in this chapter; referring to persistent storage, temporary storage, local storage and network storage. From our perspective, we mainly care about ‘time to access’, rather than durability, geographic location or any other ‘implementation’ details.</p>\n<p>It is very important to know the rough time it takes to access different storage sinks. In general, this time increases exponentially as the physical distance from the actual CPU core increases. The following list is ordered from closest to furthest for a theoretical CPU core including the rough ‘time to access’ expressed as a multiplier:</p>\n<ol>\n<li>Registers: 1x</li>\n<li>L1 cache: 5x</li>\n<li>L2 cache: 10x</li>\n<li>L3 cache: 50x </li>\n<li>Same-NUMA memory: 100x</li>\n<li>Different-NUMA memory: 300x</li>\n<li>Persistent Storage (SSD/HDD/Tape): 10000x minimum</li>\n<li>Local Data Center: 200000x</li>\n<li>Distant Data Center: 100000000x</li>\n<li>The Moon: 1000000000000x</li>\n</ol>\n<p>Our closest example storage type is the processor-local set of registers. These are the fastest accessible locations to the processor and are used as inputs and outputs for various computations. Most computers typically operate by loading data from the main memory into these registers, performing some instructions which save results to a register, and finally writing the values from registers into the main memory. Our code is turned into instructions which work with registers. The various levels of cache are optimizations for accessing the main memory.</p>\n<p>The furthest example storage type is a theoretical network drive that is within a computer on the moon. If a program wants to read or write to it, it will have to issue the command over a network spanning 384,400 kilometers. It is obvious that until we develop spacetime wormholes, greater physical distance translates into higher communication latency.</p>\n<p>Keep this list in mind when designing your programs. For low-latency applications, you will ideally never go beyond ‘same-NUMA memory’ after initial start-up is complete. <em>NUMA (Non-Uniform Memory Architecture)</em> is a multiprocessing architecture feature that assigns memory to specific CPU cores in an effort improve overall memory performance. The key takeaway: <em>try to keep your data as close the CPU as possible</em>. Of course, if our program has data persistence requirements, you will factor that in to your design.</p>\n<h2 id=\"caching\">Caching</h2>\n<p>With most modern architectures, continuous memory is loaded together as a group. When a memory address is requested to be read, surrounding data will be pulled into the various cache layers as well. This group of data is called a ‘cache line’. You can see the size of the cache line on your platform with the <strong>std::hardware_destructive_interference_size</strong> value in C++.</p>\n<p>Keeping cache mechanics in mind is important as you design your algorithms and data structures. Factoring them into your program implementation can greatly increase performance and therefore reduce latency. In general, to keep a portion of code running as fast as possible, have it access as small a range of continuous memory as possible.</p>\n<p>Put data that will be accessed as ‘a unit’ as close as possible; ideally within one cache-line for maximum performance. There are still huge benefits for using continuous memory beyond that. For example, adjacent cache lines are often prefetched. Generally use data structures that are as flat as possible (in contiguous memory) like static or dynamic arrays. They should be the default data structure of choice. Additionally, design your algorithms to fully process a block of contiguous memory before moving on (avoid going back). Sometimes this means re-arranging the order of some loops, such as with this simple matrix multiplication function:</p>\n<p>Before:</p>\n<pre><code class=\"language-c++\">using Vector = std::vector&lt;float&gt;;\nusing TwoDimMatrix = std::vector&lt;Vector&gt;;\n\nTwoDimMatrix matMul(const TwoDimMatrix&amp; m1, const TwoDimMatrix&amp; m2)\n{\n  const auto sharedDim = m1.front().size();\n  TwoDimMatrix result(m1.size(), Vector(m2.front().size()));\n  // Iterate over rows of m1\n  for (size_t i = 0; i &lt; m1.size(); ++i) {\n    // Iterate over rows of m2\n    for (size_t j = 0; j &lt; m2.size(); ++j) {\n      // Iterate over cells of m1 row and m2 column\n      for (size_t k = 0; k &lt; sharedDim; ++k) {\n        result[i][j] += m1[i][k] * m2[k][j];\n      }\n    }\n  }\n  return result;\n}\n</code></pre>\n<p>After:</p>\n<pre><code class=\"language-c++\">TwoDimMatrix matMul(const TwoDimMatrix&amp; m1, const TwoDimMatrix&amp; m2)\n{\n  const auto sharedDim = m1.front().size();\n  TwoDimMatrix result(m1.size(), Vector(m2.front().size()));\n  // Iterate over rows of m1\n  for (size_t i = 0; i &lt; m1.size(); ++i) {\n    // Iterate over cells of the m1 row and rows of m2\n    for (size_t k = 0; k &lt; sharedDim; ++k) {\n      // Iterate over cells of the m2 row\n      for (size_t j = 0; j &lt; m2.size(); ++j) {\n        result[i][j] += m1[i][k] * m2[k][j];\n      }\n    }\n  }\n  return result;\n}\n</code></pre>\n<p>All we really did was switch the k and j loop nesting order. This change can yield up to a 10x speed up as iterating over a column is much more expensive than iterating through a row. Why? The row is continuous in memory, whereas the column is not. Every time we access the next value in the column we are actually accessing a relatively ‘distant’ part of memory.</p>\n<p>Another thing to keep in mind is ‘false sharing’. If you are using atomic instructions on two memory locations that are within a single cache line, you could inadvertently slow down your program as the CPU will send an instruction to lock the cache line from other cores. This is unavoidable and desired if the two cores are actually accessing the same memory location, but if it just happens to be nearby and not the <em>same exact</em> memory location, we are paying a price for nothing. To mitigate this, you want to make sure the two memory addresses are on separate cache lines using the C++ <code>alignas</code> keyword:</p>\n<pre><code class=\"language-c++\">struct DoNotShare {\n  alignas(std::hardware_destructive_interference_size) std::atomic&lt;int&gt; one;\n  alignas(std::hardware_destructive_interference_size) std::atomic&lt;int&gt; two;\n};\n</code></pre>\n<p>This will prevent any false sharing from occurring by aligning the variables to offsets defined by the integer value returned by <strong>std::hardware_destructive_interference_size</strong>. Keep this in mind when using atomic instructions on nearby memory addresses.</p>\n<h2 id=\"chapter-summary\">Chapter Summary</h2>\n<ul>\n<li>Know the rough time taken to access different storage sinks. From same-NUMA memory cache line all the way to a computer sending RF signals from the moon.</li>\n<li>Understand the cache characteristics of your hardware.</li>\n<li>Keep in mind that that measurement is key; educated assumptions can be useful early on in the design process, but to derive conclusions you must measure performance yourself.</li>\n</ul>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Low Latency",
                   "C++"
            ],
            "date_published": "2024-03-04T12:01:37-05:00",
            "date_modified": "2024-03-04T12:01:37-05:00"
        },
        {
            "id": "https://tech.davidgorski.ca/introduction-to-low-latency-programming-minimize-branching-and-jumping/",
            "url": "https://tech.davidgorski.ca/introduction-to-low-latency-programming-minimize-branching-and-jumping/",
            "title": "Introduction To Low Latency Programming: Minimize Branching And Jumping",
            "summary": "This post originally appears as a chapter in my new book: ‘Introduction&hellip;",
            "content_html": "<p><em>This post originally appears as a chapter in my new book: ‘Introduction To Low Latency Programming’, a short and approachable entry into the subject. <a href=\"https://a.co/d/0U6KOfb\">Available now for purchase on Amazon</a>.</em></p>\n<p>This chapter will discuss how branching and jumping in our code affects our runtime performance and how we can avoid them in our effort to reduce the latency of our programs. <strong>Branching</strong> refers to process execution that can go down one of multiple paths. This functionality is provided by ‘check and jump’ instructions. <strong>Jumping</strong> refers to when the program control pointer is changed to a different location in memory rather than progressing to the next sequential instruction. This can be conditional (as a part of branching) or unconditional.</p>\n<h2 id=\"what-does-it-cost\">What Does It Cost?</h2>\n<p>Why do we want to discourage Jumping and/or Branching? Firstly, ‘comparing and jumping’ simply adds more instructions. As mentioned throughout the book, we want to minimize instructions overall. Secondly, branching disrupts the smooth flow of instruction prefetching, meaning if a condition that was not guessed by the branch predictor is encountered, the instruction pipeline has to potentially be flushed and refreshed. A new sequence of instructions will have to be retrieved.</p>\n<p>The branch predictor is an element of CPUs that aims to predict which branch will be taken in our code during runtime. Branch predictors have gotten more and more complex, but the fundamental idea is maintaining branching statistics and using them to determine where a program control address branch will most likely jump to. As mentioned in the previous paragraph, that prediction allows the pre-fetch of upcoming instructions.</p>\n<p>More instructions and instruction pipeline invalidation both contribute to the stalling of program execution. And stalling means we are not running the important instructions that directly contribute to fulfilling the business objectives. In an ideal world, our program would run these ‘golden instructions’ uninhibited.</p>\n<h2 id=\"examples-of-branching-and-jumping\">Examples Of Branching And Jumping</h2>\n<p>The following short list contains <em>some</em> common code constructs which will generate jumping and/or branching instruction constructs:</p>\n<ul>\n<li><strong>Branching and Jumping</strong>: If statements, Chained boolean conditionals, Virtual method calls</li>\n<li><strong>Jumping:</strong> Function calls</li>\n</ul>\n<h2 id=\"steps-to-reduce-branchingjumping\">Steps To Reduce Branching/Jumping</h2>\n<h3 id=\"branchless-boolean-expressions\">Branchless Boolean Expressions</h3>\n<p>Standard boolean expression operations such as <code>&amp;&amp;</code> and <code>||</code> have ‘short-circuiting’ as a feature; if previous boolean expressions evaluate to false, consecutive expressions will not be evaluated:</p>\n<pre><code class=\"language-c++\">const bool andExpression =\n  false /*will be evaluated*/ &amp;&amp;\n  true /* will not be evaluated*/;\nconst bool orExpression =\n  true /*will be evaluated*/ ||\n  false /* will not be evaluated*/;\n</code></pre>\n<p>As expected, this introduces branching to our code and should be considered for removal. What do we use instead? You can use the bitwise AND and OR expressions:</p>\n<pre><code class=\"language-c++\">const bool andExpression = false &amp; true; // Both will be evaluated\nconst bool orExpression = true | false; // Both will be evaluated\n</code></pre>\n<p>When should you switch to this approach? There is a simple rule of thumb: switch from logical to bitwise boolean expressions when the overhead cost of branching does not outweigh the cost of evaluating all terms in the expression.</p>\n<p>It still makes sense to use logical boolean expressions if consecutive expressions are expensive to evaluate. Such the following:</p>\n<pre><code class=\"language-c++\">const bool result = cheapCheck() &amp;&amp; expensiveCheck();\n</code></pre>\n<p>The short-circuiting branch allows us to avoid the expensive check, which the branchless, bitwise version would not. Tip: For the logical flavor, it makes sense to arrange the expressions in a chain from least to most expensive to enable short-circuiting before the largest computation costs would be incurred.</p>\n<p>Take a good look at the cost of the expression terms before deciding on using the branching or branchless boolean expressions.</p>\n<h3 id=\"write-code-which-generates-cmov-like-instructions\">Write Code Which Generates ‘CMOV’-like instructions</h3>\n<p><code>CMOV</code> is a built-in instruction on the x86 architecture which does a ‘conditional move (copy)’. While spiritually similar to a branch, it is significantly cheaper than real ‘check and jump’. Since we are not writing assembly by hand, we won’t be directly implementing <code>CMOV</code> use. Rather, we will try to use code constructs that will be turned into <code>CMOV</code> instructions. One of these is ternary operator. Regardless, a good compiler will use <code>CMOV</code> when it can, even for if statements (when they simply assign to a value to a variable).</p>\n<p>Ternary operator use:</p>\n<pre><code class=\"language-c++\">const int output = useFortyTwo() ? 42 : 24;\n</code></pre>\n<p>Make sure to measure the actual effect of using <code>CMOV</code> instructions with your program and data. Sometimes well-predicted branches can be more performant than <code>CMOV</code>.</p>\n<h3 id=\"remove-the-use-of-virtual-functions\">Remove The Use Of Virtual Functions</h3>\n<p>Virtual function calls perform a jump. When it comes time to call the virtual function, the generated virtual lookup table is consulted for that class. Based on the values in the table, the correct implementation of the method will be ‘jumped to’ to in the executable. This incurs a cost to load the vtable as well a branching jump. Ideally, we will avoid virtual function calls in our programs. If you are using purely virtual classes as a form of interface, you can consider using C++20 concepts instead. They will allow you to constrain generic code and allow you to create ‘interfaces’ via <code>requires</code>.</p>\n<p>Of course, for leveraging dynamic dispatch (runtime specified code execution) there is no alternative to runtime branching / jumping. Other approaches such as using sum types (<code>std::variant</code>) or type erasure all perform the same relative types of instruction. Think about if you really need dynamic dispatch.</p>\n<h3 id=\"inline-your-functions\">Inline Your Functions</h3>\n<p>Function inlining is another feature we can leverage to reduce jumps. In addition to jumping to a different location in our code and dealing with the costs of that, we also don’t have to pay the function call overhead. This overhead includes saving the register states, filling registers and/or the stack with the function arguments, incrementing the stack pointer, saving the stack return location and saving the current program control location. Function inlining puts a copy of the function body being called right at the call site. This can result in some great performance gains as there is no jump and the instruction pipeline is as simple as possible and spatially localized. You can use the GCC <code>always_inline</code> attribute above functions you want to be strictly inlined. For example:</p>\n<pre><code class=\"language-c++\">[[gnu::always_inline]\nint function(int a) {\n  return a + 11232;\n}\n</code></pre>\n<p>Even though this function would have most likely already been inlined due to its simplicity, this attribute will forcefully encourage the compiler to do so, provide a warning to us if it is unable to, and also encodes the inlining objective within the code itself for all programmers to see.</p>\n<h2 id=\"compiler-hints\">Compiler Hints</h2>\n<p>If branching is absolutely necessary in your code, you can use compiler hints to provide the compiler with extra information that it cannot infer. Using this information, the compiler will potentially re-order instructions in a way that will make the branch you marked as more ‘likely’ to be more efficient from a conditional branching perspective. This can be done using the <code>__builtin_expect</code> function or from C++20 and above with the <code>likely</code> and <code>unlikely</code> attributes. You can make the <code>__builtin_expect</code> function more ergonomic to use by creating <code>LIKELY</code> and <code>UNLIKELY</code> macros:</p>\n<pre><code class=\"language-c++\">#define LIKELY(x) __builtin_expect(!!(x), 1)\n#define UNLIKELY(x) __builtin_expect(!!(x), 0)\n</code></pre>\n<p>Let’s explore a simple use case and it’s effects. Take a look at this simple function, and it’s corresponding assembly:</p>\n<p>C++:</p>\n<pre><code class=\"language-c++\">void func(int input) {\n  if (input == 1) {\n    // BRANCH ONE\n  } else if (input == 2 ) {\n    // BRANCH TWO\n  } else {\n    // BRANCH THREE\n  }\n}\n</code></pre>\n<p>Assembly:</p>\n<pre><code class=\"language-asm\">func(int): # @func(int)\n  movq %rdi, %rax\n  leaq 1(%rdi), %rcx\n  cmpl $2, %esi\n  je .LBB0_3\n  cmpl $1, %esi\n  jne .LBB0_4\n  # BRANCH ONE\n  retq\n.LBB0_3:\n  # BRANCH TWO\n  retq\n.LBB0_4:\n  # BRANCH THREE\n  retq\n</code></pre>\n<p>Notice that the <code>cmpl</code> instruction is first executed with ‘2’ as the argument. Only after, if we didn’t jump, it will execute with ‘1’. What if we know that the value in <code>$esi</code> is more likely to be equal to ‘1’ and we want to prioritize that branch? Let’s add a <code>LIKELY</code> annotation to our C++ code:</p>\n<pre><code class=\"language-c++\">void func(int input) {\n  if (LIKELY(input == 1)) {\n    // BRANCH ONE\n  } else if (input == 2 ) {\n    // BRANCH TWO\n  } else {\n    // BRANCH THREE\n  }\n}\n</code></pre>\n<p>Now we can observe the different in output assembly:</p>\n<pre><code class=\"language-asm\">func(int): # @func(int)\n  pushq %rbx\n  cmpl $1, %esi\n  jne .LBB0_1\n  # BRANCH ONE\n  retq\n.LBB0_1:\n  cmpl $2, %esi\n  jne .LBB0_4\n  # BRANCH TWO\n  retq\n.LBB0_4:\n  # BRANCH THREE\n  retq\n</code></pre>\n<p>As you can see, the compiler re-arranged the branching instructions. The comparison of <code>%eri</code> with 1 is now part of the first call to <code>cmpl</code> + <code>jne</code> and if equality is determined we don’t jump anywhere else. Spatially, we are already at the <code>BRANCH ONE</code> code. The compiler also moved the remaining conditionals after the first jump at <code>.LBB0_1:</code>. It is quite apparent that all remaining cases are deprioritized from an optimization standpoint in comparison to <code>BRANCH ONE</code>.</p>\n<p>Now for some semantic rambling. Even though they have been accepted as standard terms, likely and unlikely are not really accurate from a definition perspective. You are not really marking that one conditional branch is more likely than the other to occur. What you are doing is telling the compiler that you want to optimize for this conditional branch. Perhaps <code>OPTIMIZE</code> and <code>UNOPTIMIZE</code> are more accurate terms for our construct. Making your code as readable/understandable/surface-level as possible is always something worth pursuing.</p>\n<h2 id=\"cheaper-branching\">Cheaper Branching</h2>\n<p>Not all ‘branching’ instructions are created equally. Consider the following function that that performs a few <strong>compare and jumps</strong>:</p>\n<pre><code class=\"language-c++\">void processThisString(std::string_view input)\n{\n  if (input == &quot;production&quot;) {\n    processProd(input);\n  } else if (input == &quot;RC&quot;) {\n    processRC(input);\n  } else if (input == &quot;beta&quot;)\n    processBeta(input);\n  }\n}\n</code></pre>\n<p>This is a ‘run-of-the-mill’ if statement. However, we have an opportunity here: the comparison set is very constrained. In fact, most the calls to the <code>==</code> operator distill to a <code>memcmp</code> which will short circuit after the first character, since all the first characters in the string literals are different. For example, if the input’s value is “beta”, we will perform two calls to <code>==</code> for nothing. Instead, we can re-write this in a more efficient manner by using the <code>switch</code> construct on that first character:</p>\n<pre><code class=\"language-c++\">void processThisString(std::string_view input)\n{\n  constexpr auto i = 0;\n  switch (input[i]) {\n    case &quot;production&quot;[i]: processProd(input); break;\n    case &quot;RC&quot;[i]: processRC(input); break;\n    case &quot;beta&quot;[i]: processBeta(input); break;\n  }\n}\n</code></pre>\n<p>The compiler will most likely generate a more efficient branching construct using jump tables and binary decision trees since data of only 1 char width is being compared now. A best-case scenario would be if the range of first character values is very limited, because then a single jump table would be used to increment the program control pointer. Of course, this is not cut and dry, because a small set of inputs may cause an if statement to perform better. Always measure! Regardless, this is a good approach to keep in mind for optimization.</p>\n<h2 id=\"chapter-summary\">Chapter Summary</h2>\n<ul>\n<li>Jumping to distant code locations or branching can incur a heavy cost in low latency segments of the code. This is due to added instructions, instruction pipeline de-optimization and cache eviction.</li>\n<li>Examples of Branching/Jumping include: if statements, chained conditionals, virtual method calls, and function calls in general.</li>\n<li>You can avoid branching/jumping by using branchless conditionals, Using ‘CMOV’ instructions, Remove the use of virtual functions and try to inline your functions.</li>\n<li>If branching is unavoidable, try to use a ‘cheaper’ variation of it.</li>\n</ul>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Low Latency",
                   "C++"
            ],
            "date_published": "2024-02-26T15:42:03-05:00",
            "date_modified": "2024-02-26T15:42:03-05:00"
        },
        {
            "id": "https://tech.davidgorski.ca/announcing-my-book-introduction-to-low-latency-programming/",
            "url": "https://tech.davidgorski.ca/announcing-my-book-introduction-to-low-latency-programming/",
            "title": "Announcing My First Book: Introduction To Low Latency Programming",
            "summary": "I’m excited to announce the availability of my first technical book: Introduction&hellip;",
            "content_html": "<p>I’m excited to announce the availability of my first technical book:</p>\n<p><strong>Introduction To Low Latency Programming</strong> </p>\n<p>Amazon Link: <a href=\"https://a.co/d/0U6KOfb\">https://a.co/d/0U6KOfb</a></p>\n<p>It is a short, beginner-friendly entry into the domain of high-performance, bare metal coding. Learning low latency programming can be intimidating and online resources are scattered. Since there are no introductory books on the subject, my hope is that I can help programmers ‘kick start’ their entry into the domain gently. While this the book is not ‘deep’, it touches on important technical topics and ideas, provides many code examples and discusses the effects of modern hardware on optimization problems.</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
            ],
            "date_published": "2024-02-23T11:12:14-05:00",
            "date_modified": "2024-02-23T11:13:38-05:00"
        },
        {
            "id": "https://tech.davidgorski.ca/literary-programming/",
            "url": "https://tech.davidgorski.ca/literary-programming/",
            "title": "Literary Programming",
            "summary": "Code is written once, but read many times. Given this truth, it&hellip;",
            "content_html": "<p>Code is written once, but read many times. Given this truth, it makes sense to prioritize read-ability over write-ability. Readable code contains good variable names, uses appropriate abstractions and is understood easily. Many have waved the flag of ‘Clean Code’ for quite a few decades now.</p>\n<p>What has helped me write code that I consider clear and readable is something I call <em>Literary Programming</em>. Not to be confused with <a href=\"https://en.wikipedia.org/wiki/Literate_programming\">Literate Programming</a>. I would change the name of my concept but I’ve grown rather fond of it. Apologies in advance.</p>\n<p>What I call <em>Literary Programming</em> is the deliberate application of structured grammar and story-telling into the naming, abstracting and composition of code. It is the conscious act of letting your code capture a narrative with your choice of words. Not leaving intentions and actions in a state of vagueness; method names should reflect what is actually being done within and the meaning of the return value, intermediate variables are encouraged.</p>\n<p>Don’t overanalyze what I am trying to say. This isn’t a very strict set of rules. It may just be synonymous with ‘Good Code’ to you. It is a simple idea meant to inspire a little more scrutiny in you when creating APIs, choosing names, composing expressions and designing the structure of your application.</p>\n<p>Here are just some ways you can make your more <strong>literary</strong>:</p>\n<ul>\n<li>Use abstractions to ‘shorten’ portions of code. Simple example: putting argument and configuration parsing in a separate function to keep the rest of the <code>main</code> as clean as possible.</li>\n<li>Put great care into class API design; as much detail as possible into method names. Prefer a name like <strong>processIncomingMessages()</strong> over <strong>process()</strong> or <strong>messages()</strong>. <strong>getOrCreateItem()</strong> over <strong>getItem()</strong> or <strong>createItem()</strong> for a method that will return an existing object if it already exists.</li>\n<li>Value consistency. One method shouldn’t be named <strong>bool error()</strong> while it’s counterpart is named <strong>bool isValid()</strong>.</li>\n<li>Use intermediate variables to compose expressions. These variables serve as logic checkpoints for the future reader.</li>\n<li>Wrap complicated loop conditions into a boolean-returning functor. Take this call site as an example: <code>while (continueRunning(itemsLeft, maxItemsToProcess, error))</code>.</li>\n<li>As mentioned before; good naming pays dividends.</li>\n</ul>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "style",
                   "Programming"
            ],
            "date_published": "2024-02-09T16:41:04-05:00",
            "date_modified": "2024-02-09T16:44:51-05:00"
        },
        {
            "id": "https://tech.davidgorski.ca/c-mini-pattern-deriving-from-stdvariant/",
            "url": "https://tech.davidgorski.ca/c-mini-pattern-deriving-from-stdvariant/",
            "title": "C++ Pattern: Deriving From std::variant",
            "summary": "I am a big fan of sum types for expressive programming. They&hellip;",
            "content_html": "<p>I am a big fan of sum types for expressive programming. They provide an elegant way to encode mutually exclusive data types in a single field. While not provided by the language itself, the C++ standard library offers us <code>std::variant</code>. Since there is no language-level pattern matching construct, interacting with variants can be less than ergonomic. One way to mitigate this is inheriting from <code>std::variant</code> and creating useful domain-specific access methods. This article discusses a few different ways of deriving from <code>std::variant</code> that might be useful and/or interesting.</p>\n<h2 id=\"a-result-type\">A Result Type</h2>\n<p>To start off we’ll create a ~15 line class derived from <code>std::variant</code> that fulfills the basics of a result type (something like C++23 <code>std::expected</code> but available in C++17 and above). This is a nice way to encapsulate success and failures types in a united interface. Implementation:</p>\n<pre><code class=\"language-c++\">#include &lt;variant&gt;\n\ntemplate&lt;typename T, typename Error&gt;\nclass Result : public std::variant&lt;T, Error&gt; {\npublic:\n  using std::variant&lt;T, Error&gt;::variant;\n  using std::variant&lt;T, Error&gt;::operator=;\n  \n    Error* error() { return std::get_if&lt;Error&gt;(this); }\n    const Error* error() const { return std::get_if&lt;Error&gt;(this); }\n    T* value() { return std::get_if&lt;T&gt;(this); }\n    const T* value() const { return std::get_if&lt;T&gt;(this); }\n    T* operator-&gt;() { return value(); }\n    const T* operator-&gt;() const { return value(); }\n    operator bool() const { return error() == nullptr; }\n};\n</code></pre>\n<p>We derive from <code>std::variant</code> to take advantage of the ergonomic constructors and assignment operators (meaning we don’t have to implement them for each type and each reference type; doing this correctly is tedious). After this, we add two convenient methods to access the underlying types (along with const overloads). And finally, define <code>operator-&gt;</code> to allow access to the underlying success type value and <code>operator bool</code> to determine whether it holds the success type (along with const overloads).</p>\n<p>To demonstrate basic usage we can create a small type hierarchy with success and failure types:</p>\n<pre><code class=\"language-c++\">struct SuccessResult {\n  int date;\n  double time;\n};\nstruct ErrorResult {\n  std::string message;\n};\nusing ProcessResult = Result&lt;SuccessResult, ErrorResult&gt;;\n</code></pre>\n<p>Then we create a function to demonstate it’s usage:</p>\n<pre><code>ProcessResult process(std::string_view input) {\n  return ErrorResult{ &quot;Not implemented&quot; };\n}\n</code></pre>\n<p>And finally we call the function and write some code that observes the return value:</p>\n<pre><code>const auto result = process(&quot;Hello&quot;);\nif (!result) {\n  std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; result.error()-&gt;message &lt;&lt; std::endl;\n} else {\n  std::cout &lt;&lt; &quot;Date: &quot; &lt;&lt; result-&gt;date &lt;&lt; &quot; Time: &quot; &lt;&lt; result-&gt;time &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Overall, this approach is highly ergonomic, concise and clear. The call site is easily understood since <code>operator bool</code> cleanly checks the status, <code>operator -&gt;</code> eliminates unnecessary intermediate variables and method calls. The <code>error()</code> access method is also self-explanatory.</p>\n<h2 id=\"data-or-pointer-to-data\">Data Or Pointer to Data</h2>\n<p>Another potentially useful class we can build is <code>DataOrPointer</code>. This is a class that either holds a type or a pointer to that type. Again we provide ergonomic access methods and operators:</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nclass DataOrPointer : public std::variant&lt;T, T*&gt; {\npublic:\n  using std::variant&lt;T, T*&gt;::variant;\n  using std::variant&lt;T, T*&gt;::operator=;\n  operator const T&amp;() const {\n    if (auto value = std::get_if&lt;T&gt;(this); value) {\n      return *value;\n    }\n    return *std::get&lt;T*&gt;(*this);\n  }\n};\n</code></pre>\n<p>You can use this if you want to provide a single return type to a function that takes a <code>T</code> as an argument and may or may not return a newly constructed <code>T</code> object after testing some conditions. If constructing <code>T</code> is expensive, this approach can be a clean way to achieve the objective. A real-world example of this could be normalizing two BigFloats to use the same exponent before operating on them. If the target exponent is equal to the current exponent, it would be a waste to build a new copy (In this case we can’t mutate the original numbers).</p>\n<pre><code>DataOrPointer&lt;const UnsignedBigFloat&gt; usingExponent(const UnsignedBigFloat&amp; value, int64_t exponent)  {\n    if (exponent == value._exponent) {\n        return DataOrPointer&lt;const UnsignedBigFloat&gt;(&amp;value);\n     }\n\n    auto copy = value;\n    copy._mantissa.timesTenToThe(exponent - value._exponent);\n    copy._exponent = exponent;\n    return std::move(copy);\n}\n</code></pre>\n<h2 id=\"multi-type-reference\">Multi-Type Reference</h2>\n<p>I will admit the following example is almost too esoteric to be useful, but I have actually reached for this once before.</p>\n<p>The challenge: create a reference that can bind to one of multiple types, performance not being critical and reducing code duplication being the main objective.</p>\n<p>Solution:</p>\n<pre><code class=\"language-c++\">template&lt;typename... Ts&gt;\nclass MultiTypeReference : public std::variant&lt;Ts*...&gt; {\npublic:\n  using std::variant&lt;Ts*...&gt;::variant;\n\n  template&lt;typename T&gt;\n  auto&amp; operator=(T value) {\n    std::visit([&amp;](auto&amp; pointer) { *pointer = value; }, *this);\n    return *this;\n  }\n\n  template&lt;typename T&gt;\n  operator T() {\n    return std::visit([&amp;](auto&amp; pointer) { return T(*pointer); }, *this);\n  }\n</code></pre>\n<p>Yes, this works. Yes, it’s weird. No, I don’t encourage you to use it. However, it is an interesting case study and hopefully gets you thinking about how to stretch the use of <code>std::variant</code>. Here’s how one would actually use it:</p>\n<pre><code>struct Data {\n   bool useFieldA;\n   int32_t A;\n     int64_t B;\n};\n\nMultiTypeReference&lt;int32_t, int64_t&gt; getRelevantField(Data&amp; data) {\n    return data.useFieldA ?\n          MultiTypeReference&lt;int32_t, int64_t&gt;(data.A) :\n          MultiTypeReference&lt;int32_t, int64_t&gt;(data.B);\n}\n\nvoid assignOne(Data&amp; one) {\n  getRelevantField(one) = 1;\n}\n</code></pre>\n<p>At the end of the day, yes, this simply hides the conditional access and assignment behind some abstractions. But in use, it behaves exactly how we want it: a reference to one of multiple types.</p>\n<h2 id=\"epilogue\">Epilogue</h2>\n<p>The reason I included the word ‘Pattern’ in the title is because these ideas can be extended to theoretically endless types and custom access methods.</p>\n<p>For examples, you could build a result type with three different possible types and provide access methods for them (removing <code>operator-&gt;</code>). Or perhaps you provide a <code>transform</code> method that takes a functor and changes the value to hold a different type after transforming the current type. Or even just provide custom comparison operators (Which could be necessary for sorting different numeric types; imagine you want to sort a vector of regular int and BigInt references stored within a variant-type).</p>\n<p>In review, the key tools to leverage are:</p>\n<ol>\n<li>Using the constructors and assignment operators provided by <code>std::variant</code>.</li>\n<li>Defining named access methods for different types.</li>\n<li>Providing an <code>operator-&gt;</code> for a success or special type.</li>\n<li>Providing conversion operators for syntax-less unpacking.</li>\n</ol>\n<p>I hope my discussion of these concepts was useful or at least interesting. Thanks for reading! Subscribe via RSS or <a href=\"https://www.linkedin.com/in/dgski/\">LinkedIn</a>.</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
            ],
            "date_published": "2024-01-09T22:00:00-05:00",
            "date_modified": "2024-01-31T20:59:35-05:00"
        },
        {
            "id": "https://tech.davidgorski.ca/c-iterator-friendly-branchless-binary-search/",
            "url": "https://tech.davidgorski.ca/c-iterator-friendly-branchless-binary-search/",
            "title": "C++ Iterator-Friendly Branchless Binary Search",
            "summary": "Once you delve into the realm of low-latency C++, you will find&hellip;",
            "content_html": "<p>Once you delve into the realm of low-latency C++, you will find yourself waking up in the middle of the night, sweating profusely from a nightmare concerning unnecessary branching. And soon after, you begin to over-optimize your code to avoid branches. Even when that part of your code is clearly not the bottleneck.</p>\n<p>This is a short post presenting a C++ iterator-friendly implementation of a branchless binary search implementation. It is short and sweet, so I will reveal it before some editorial comments and thanks:</p>\n<pre><code>template&lt;typename It&gt;\nIt lower_bound(It begin, It end, const typename It::value_type&amp; value) {\n  auto len = std::distance(begin, end);\n  if (len == 0) {\n    return end;\n  }\n\n  while (len &gt; 1) {\n    const auto half = len / 2;\n    begin += (*(begin + half - 1) &lt; value) * half;\n    len -= half;\n  }\n  return (*begin &lt; value) ? end : begin;\n}\n</code></pre>\n<p>This implementation uses a <code>begin</code> iterator and <code>len</code> integer to keep track of the search space rather than begin and end pointers/indices. So the first line of the function are simply using the provided iterators to derive the needed variables. We terminate early if the range is empty. All classic binary search branches within the <code>while</code> loop body have been removed:</p>\n<ul>\n<li>Shrinking the search space length without branches is easy; it will always halve. We can do this safely by subtracting <code>halfLen</code> from the remaining <code>len</code> (This will potentially leave an array of size 1).</li>\n<li>Calculating the new search space start is more tricky. It will either be the same <code>begin</code> as now, or be the halfway point between pos and the end of the search space. So we conditionally add <code>halfLen</code> to <code>begin</code>.</li>\n<li>To conform to the <code>std::lower_bound</code> interface, we must return the end iterator if the value is not found within the range. To do so, unfortunately we must add a final conditional at the end of the function. Thanks to <a href=\"https://www.linkedin.com/in/farid-mehrabi/\">Farhid Mehrabi</a> for pointing this bug out in my initial implementation (I would potentially return a value that is less than the value, breaking the lower bound contract). Adding a simple unit test would have prevented my from doing so, so this a reminder to myself to do so even for small pieces of code.</li>\n</ul>\n<p>For the most part, this implementation will have superior performance to <code>std::lower_bound</code>. There is caveat: since the addition to <code>begin</code> will most likely be turned into a <code>CMOV</code> instruction rather than a proper branch, there will be no prediction to preload the next search space mid-points and at larger array sizes, a classic approach will prevail. This can potentially be mitigated on some platforms by adding an explicit <code>prefetch</code> instruction.</p>\n<p>Thanks to <a href=\"https://en.algorithmica.org/hpc/data-structures/binary-search/\">this amazing article</a> for outlining this concept using raw arrays.</p>\n<h2 id=\"benchmarks\">Benchmarks</h2>\n<p>Nanoseconds taken to find 1000 random numbers that are in the range on Macbook Air M1. <a href=\"https://gist.github.com/dgski/c48142bcb96cc3bf0bf14fe1072e403f\">Code</a>.</p>\n<pre><code>=============================\narray size = 1\nbranchlessTime = 18000\nstdTime        = 18000\n=============================\narray size = 2\nbranchlessTime = 18000\nstdTime        = 30000\n=============================\narray size = 4\nbranchlessTime = 19000\nstdTime        = 39000\n=============================\narray size = 8\nbranchlessTime = 19000\nstdTime        = 48000\n=============================\narray size = 16\nbranchlessTime = 20000\nstdTime        = 59000\n=============================\narray size = 32\nbranchlessTime = 21000\nstdTime        = 69000\n=============================\narray size = 64\nbranchlessTime = 21000\nstdTime        = 78000\n=============================\narray size = 128\nbranchlessTime = 22000\nstdTime        = 91000\n=============================\narray size = 256\nbranchlessTime = 24000\nstdTime        = 103000\n=============================\narray size = 512\nbranchlessTime = 28000\nstdTime        = 113000\n=============================\narray size = 1024\nbranchlessTime = 31000\nstdTime        = 127000\n=============================\narray size = 2048\nbranchlessTime = 35000\nstdTime        = 139000\n=============================\narray size = 4096\nbranchlessTime = 38000\nstdTime        = 146000\n=============================\narray size = 8192\nbranchlessTime = 42000\nstdTime        = 140000\n=============================\narray size = 16384\nbranchlessTime = 40000\nstdTime        = 139000\n=============================\narray size = 32768\nbranchlessTime = 45000\nstdTime        = 149000\n=============================\narray size = 65536\nbranchlessTime = 64000\nstdTime        = 189000\n=============================\narray size = 131072\nbranchlessTime = 79000\nstdTime        = 216000\n=============================\narray size = 262144\nbranchlessTime = 91000\nstdTime        = 233000\n=============================\narray size = 524288\nbranchlessTime = 105000\nstdTime        = 260000\n=============================\narray size = 1048576\nbranchlessTime = 195000\nstdTime        = 351000\n=============================\narray size = 2097152\nbranchlessTime = 142000\nstdTime        = 333000\n=============================\narray size = 4194304\nbranchlessTime = 397000\nstdTime        = 444000\n=============================\narray size = 8388608\nbranchlessTime = 931000\nstdTime        = 961000\n=============================\narray size = 16777216\nbranchlessTime = 1159000\nstdTime        = 996000\n=============================\narray size = 33554432\nbranchlessTime = 1327000\nstdTime        = 1132000\n=============================\narray size = 67108864\nbranchlessTime = 1507000\nstdTime        = 1578000\n=============================\narray size = 134217728\nbranchlessTime = 1603000\nstdTime        = 1710000\n=============================\narray size = 268435456\nbranchlessTime = 5921000\nstdTime        = 5980000\n=============================\narray size = 536870912\nbranchlessTime = 23558000\nstdTime        = 15002000\n</code></pre>\n<p>As you can see the benefits start to deteriorate as the array size grows.</p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
            ],
            "date_published": "2023-12-17T14:32:39-05:00",
            "date_modified": "2023-12-18T09:36:35-05:00"
        },
        {
            "id": "https://tech.davidgorski.ca/truncating-string-white-space-at-compile-time-in-c/",
            "url": "https://tech.davidgorski.ca/truncating-string-white-space-at-compile-time-in-c/",
            "title": "Truncating String White-space At Compile Time in C++",
            "summary": "One problem that arises when interleaving SQL queries in C++ code is&hellip;",
            "content_html": "<p>One problem that arises when interleaving SQL queries in C++ code is string literal formatting and spacing. Most queries are much more human-digestible in a multi-line format. C++ treats adjacent string literals as one, so the traditional C++ solution is this:</p>\n<pre><code class=\"language-c++\">const char* query =\n    &quot; SELECT &quot;\n        &quot; u.id, &quot;\n        &quot; u.user_name, &quot;\n        &quot; u.ref_id, &quot;\n        &quot; u.postal_code, &quot;\n        &quot; u.email, &quot;\n        &quot; o.transaction.id &quot;\n    &quot; FROM &quot;\n        &quot; users u &quot;\n    &quot; JOIN &quot;\n        &quot; orders o ON o.user_id = u.id &quot;\n    &quot; WHERE &quot;\n        &quot; u.id=? AND u.active=? &quot;;\n</code></pre>\n<p>A programmer has to be very careful with the white-space before and after the SQL tokens as their presence or lack-thereof could be the difference between a good night’s sleep, or a run-time exception triggering a on-call alert late at night. Fun! Overall this code snippet is much more difficult to read due to the syntactical mess of quotation marks around it. To help prevent issues I have even heard this old platitude from a veteran C++ programmer: “A good surgeon washes his hands before and after the surgery”; mandating spaces at the beginning and end of each line. Is a rule of thumb really a best practice? One’s best work is done with as little distraction as possible, and this is something else to worry about.</p>\n<p>Modern C++ provides us with one useful addition that can help mitigate this issue: the raw string literal. Leveraging this feature we can write the query naturally; all within one pair of quotations:</p>\n<pre><code class=\"language-c++\">const char* query = R&quot;(\n    SELECT\n        u.id,\n        u.user_name,\n        u.ref_id,\n        u.postal_code,\n        u.email,\n        o.transaction.id\n    FROM\n        users u\n    JOIN\n        orders o ON o.user_id = u.id\n    WHERE\n        u.id=? AND u.active=?\n)&quot;;\n</code></pre>\n<p>This works rather well. You can define the same exact query, presented very simply and clear. You don’t have to ‘worry’ about the C++ surrounding the SQL. You can just focus on the SQL. The problem is, all those spaces, tabs and newline characters are also in the final query string. The raw string is <strong>298 characters</strong> long versus the original <strong>166 characters</strong>. This means you pass a query string that is almost <strong>double in length</strong> to any query parsing function/module. Now, with the performance of modern hardware this penalty is negligible. However, sometimes, this code is ran in a hot path or you might have a sense of guilt for such an obvious efficiency sacrifice. Let’s make things right in the universe…</p>\n<p>The first, conceptually simplest, obvious solution is to run a string-slimming function on all queries when program execution starts. This approach is good enough, but all sub-approaches in this branch have disadvantages:</p>\n<ul>\n<li>If you want the query to be ready before a certain function is called, you will unfortunately have to move the query variable out of it’s logical code block. This can reduce the clarity of intent and logic locality.</li>\n<li>If you want to keep the query nested where it’s used, you will have to devise some kind of static initialization function that runs the first time the function is called. A static flag will have to be checked every time the function is called to determine whether the string has been ‘slimmed’ yet.</li>\n<li>You will need to allocate a new destination buffer for the ‘slimmed’ query.</li>\n</ul>\n<p>As suggested by this article’s title we can actually do this string processing at compile time, with no penalty to our code’s logic or clarity. </p>\n<h2 id=\"contexpr-variables-functions-and-classes\">‘contexpr’ Variables, Functions and Classes</h2>\n<p>Modern C++ provides the <a href=\"https://en.cppreference.com/w/cpp/language/constexpr\">constexpr</a> functionality to provide compile-time code utilities. There are a lot of resources available online detailing this, so I won’t go into detail. Fundamentally, you can mark your functions, classes and variables with the <strong>constexpr</strong> keyword to signify they could potentially be called or created at compile time. This is not a guarantee, but a contract of sorts. A summary of the rules:</p>\n<ul>\n<li>A <strong>constexpr variable</strong> must be initialized as a constexpr type with a constepxr function. These must be constructed/called with either literals or other constexpr variables as arguments.</li>\n<li>A <strong>constexpr function</strong> can only take and return constexpr types. The key thing to know is that arguments can be accepted as constexpr, but not passed on as constexpr. Once within the function you cannot guarantee the argument values are known at compile time, even though they might be.</li>\n<li>A <strong>constexpr type/class</strong> can only have constexpr type members and must at least one constexpr constructor. All scalar types and arrays are considered constexpr.</li>\n</ul>\n<p>I’m fairly new to <strong>constexpr</strong> myself, so please do your own research, and reach out if I’m incorrect.</p>\n<h2 id=\"implementing-a-compile-time-string\">Implementing a Compile Time String</h2>\n<p>In order to perform our string parsing/creation at compile time, we need to implement a string class that satisfies the constexpr ‘contract’ for types. We must ensure that all methods we want to call after the constexpr variable construction are marked as ‘const’. The implementation is pretty self explanatory when keeping in mind the restrictions:</p>\n<pre><code class=\"language-c++\">namespace compiletime {\n\ntemplate&lt;std::size_t MaxSize = 30&gt;\nclass string\n{\n    char m_data[MaxSize] = { 0 };\n    std::size_t m_size;\npublic:\n    constexpr string() : m_data({}), m_size(0) {}\n    constexpr string(const char* str) : m_data(), m_size(0) {\n        for(int i =0; i&lt;MaxSize; ++i) {\n            m_data[m_size++] = str[i];\n        }\n    }\n    \n    constexpr char const* data() const { return m_data; }\n    constexpr operator const char*() const { return data(); } // for convenience\n    constexpr void push_back(char c) { m_data[m_size++] = c; }\n    constexpr char&amp; operator[](std::size_t i) { return m_data[i]; }\n    constexpr char const&amp; operator[](std::size_t i) const { return m_data[i]; }\n    constexpr size_t size() const { return m_size; }\n    constexpr const char* begin() const { return std::begin(m_data); }\n    constexpr const char* end() const { return std::begin(m_data) + m_size; }\n};\n\n}\n</code></pre>\n<h2 id=\"2-implementing-a-compile-time-parser\">2. Implementing a Compile Time Parser</h2>\n<p>Now that we have a string class that can used with <strong>constexpr variables</strong>, we can run <strong>constepxr</strong> functions that take this string type as arguments. Remember, in constexpr functions all arguments can be accepted as constexpr, but not passed as constexpr. Additionally, we can only use other constexpr functions and types within the function.</p>\n<p>First, let’s implement a simple function which checks if a provided character is a whitespace character:</p>\n<pre><code class=\"language-c++\">constexpr bool is_whitespace(char c) {\n    return\n        (c == &#39; &#39;) ||\n        (c == &#39;\\t&#39;) ||\n        (c == &#39;\\n&#39;) ||\n        (c == &#39;\\v&#39;) ||\n        (c == &#39;\\f&#39;) ||\n        (c == &#39;\\r&#39;);\n}\n</code></pre>\n<p>Notice the <em>constexpr</em> keyword as well as the fact that all types used (char) are constexpr-friendly. The actual ‘business logic’ is self-explanatory.</p>\n<p>Moving on and focusing on our goal, the function we want to implement takes one <strong>compiletime::string</strong>, iterates over it, and removes consecutive white-space and newlines. This can be done via a simple for-loop, with <strong>push_back</strong> calls appending the preserved characters to a new <strong>compiletime::string</strong> instance. A few predicates allow us to keep track of the parser state. Check it out:</p>\n<pre><code class=\"language-c++\">template&lt;std::size_t N&gt;\nconstexpr auto truncateWhitespace(compiletime::string&lt;N&gt; str) {\n    // Need to use non-type template for string max size\n    compiletime::string&lt;N&gt; result;\n    bool previousIsWhitespace = false; // Keep track if the previous character was whitespace\n    for(char c : str) {\n        // Skip new lines\n        if(c == &#39;\\n&#39;) {\n            continue;\n        } else if(is_whitespace(c)) {\n            // If the last character was whitespace, continue interation\n            if(previousIsWhitespace) {\n                continue;\n            }\n            // Whitespace: Set flag\n            previousIsWhitespace = true;\n        } else {\n            // Not whitespace: Reset flag\n            previousIsWhitespace = false;\n        }\n\n        result.push_back(c); // Otherwise; add character to new string\n    }\n    return result;\n}\n</code></pre>\n<p>And finally, we can provide a simple overload to allow direct string literal use:</p>\n<pre><code class=\"language-c++\">template&lt;std::size_t N&gt;\nconstexpr auto truncateWhitespace(const char (&amp;str)[N])\n{\n    compiletime::string&lt;N&gt; tmp(str); // build instance\n    return truncateWhitespace(tmp); // run function\n}\n</code></pre>\n<h2 id=\"the-spoils\">The Spoils</h2>\n<p>Now, we can actually use this construct in our code:</p>\n<pre><code class=\"language-c++\">constexpr auto query = R&quot;(\n    SELECT\n        u.id,\n        u.user_name,\n        u.ref_id,\n        u.postal_code,\n        u.email,\n        o.transaction.id\n    FROM\n        users u\n    JOIN\n        orders o ON o.user_id = u.id\n    WHERE\n        u.id=? AND u.active=?\n)&quot;;\n\nconstexpr auto trucatedQuery = truncateWhitespace(query);\nstd::cout &lt;&lt; trucatedQuery;\n// output:\n// &quot; SELECT u.id, u.user_name, u.ref_id, u.postal_code, u.email, o.transaction.id FROM users u JOIN orders o ON o.user_id = u.id WHERE u.id=? AND u.active=? &quot;\n</code></pre>\n<p>The new query length is <strong>154 characters</strong>! Which beats obviously beats the original raw literal (294) and the old “spaces before and after” mantra with traditional one-line string literals (162). And we can validate that this is actually happening at compile time with a <a href=\"https://www.google.com/search?channel=fs&amp;client=ubuntu&amp;q=static+assert\">static_assert</a>. If you are using a modern IDE/Editor with C++ integration the following statement will actually be highlighted as a failed assertion before running compilation:</p>\n<pre><code>static_assert(trucatedQuery.size() == 154);\n</code></pre>\n<p>We have succeeded and in the process gained advantages over both previous approaches:</p>\n<ul>\n<li><strong>Clearer and less cluttered code site</strong>: Freedom to use raw string literals to format queries with as much indentation as you’d like.</li>\n<li><strong>Neater, Compact Logging</strong>: New lines scattered in log files make them harder to parse and understand.</li>\n<li><strong>Less Network Bandwidth Usage</strong>: If you are using a database that directly accepts the query string, you will be sending half the bytes over the network.</li>\n<li><strong>Faster Performance</strong>: If you do any local string validation/processing/formatting, you will gain some performance.</li>\n</ul>\n<p>For the sake of it, I did a simple benchmark comparing the generated <strong>compile_time::string</strong> buffer to a <strong>const char</strong>* with the exact same literal. On my system, iterating over the provided string using a simple pointer and while loop resulted in consistently faster performance averaged over many iterations. I would be greatly concerned if it didn’t, as there is now half as many characters as before! A simple O(N) iteration operation will obviously be faster on less elements.</p>\n<p>I can see this technique providing excellent payoff for queries with many joins and deeper indentation (maybe in a lambda inside a class member function or something), sent over the network and parsed on a regular, frequent basis. It’s also just feels great, knowing you’ve reached the holy grail of performance; aka compile time operations.</p>\n<h2 id=\"limitations\">Limitations</h2>\n<p>There is one obvious limitation of this approach. Even though the ‘string’ value is shortened, we pack a buffer of the original size into the executable, padded with zeroes at the end of the string. This is because the final string size is needed as a compile time template value to construct the string class. Unfortunately, once we’re inside the <strong>truncateWhitespace</strong> function, we can’t retrieve the length to use with the string type. We also can’t make any assumptions about what the final size will be as there may not be any superfluous white-space (A simple N / 2 estimate could result in compilation failures in some cases). You could solve this this by implementing a constexpr function to calculate the final length before doing the actual truncation. Something like this:</p>\n<pre><code class=\"language-c++\">constexpr const char originalQuery[] = R&quot;(...)&quot;;\nconstexpr std::size_t slimmedSize = calculateTruncatedWhitespaceSize(originalQuery);\nconstexpr auto trucatedQuery = truncateWhitespace&lt;slimmedSize&gt;(originalQuery);\n</code></pre>\n<p>I cannot currently think of a way to do this in a way does not leverage a macro, as we can’t create function to wrap this functionality, since the arguments would not be considered constexpr inside and therefore could not be used calculate a constexpr length to be provided as a non-type template parameter to the string class. Please let me know if you can suggest a technique or trick!</p>\n<p>Another limitation is using string literals within the SQL itself. Luckily, this can be mitigated by enhancing the parser to keep track if the current point of iteration is within a string literal or not.</p>\n<h2 id=\"in-closing\">In Closing</h2>\n<p>Though the performance gains are negligible in most cases, this approach provides real benefits in clarity, logging and efficiency. You can leverage this same technique to do any kind of string pre-processing at compile time as needed.</p>\n<p><a href=\"https://gist.github.com/dgski/810ede7c4a80917c0adc99c6852fee9a\">Link to Complete Code</a></p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "constexpr",
                   "Programming",
                   "C++"
            ],
            "date_published": "2021-04-17T12:00:00-04:00",
            "date_modified": "2023-07-29T14:33:32-04:00"
        },
        {
            "id": "https://tech.davidgorski.ca/using-c17-to-create-composable-recursive-data-types/",
            "url": "https://tech.davidgorski.ca/using-c17-to-create-composable-recursive-data-types/",
            "title": "Using C++17 to Create Composable, Recursive Data Types",
            "summary": "This article presents a simple way to cleanly define nested, multi-branch type&hellip;",
            "content_html": "<p>This article presents a simple way to cleanly define nested, multi-branch type hierarchies using C++17. An endeavour which was much messier in older versions of C++. This can be altered and modified to generated pure schemas, new data types, and anything tree based. It leverages <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">std::variant</a> to cleanly express a cohesive approach to designing easily composed data structures.</p>\n<p>The final result will allow us to easily define N-Arity tree instances with clear, nested object instance declaration. For example:</p>\n<pre><code class=\"language-c++\">auto root =\n    Node(&quot;addUserRequest&quot;,\n        Sequence({\n            Node(&quot;userId&quot;, 123),\n            Node(&quot;name&quot;, &quot;Charles&quot;),\n            Node(&quot;age&quot;, 424),\n            Node(&quot;sessionInfo&quot;,\n                Sequence({\n                    Node(&quot;signOnId&quot;, &quot;f1f133112&quot;),\n                    Node(&quot;bannerId&quot;, Null())}))}));\n</code></pre>\n<h2 id=\"declaring-our-building-blocks\">Declaring Our Building Blocks</h2>\n<p>In order to get started, we need to declare the fundamental types that will allows to construct this tree system. These will include our ‘simple’, scalar data types which hold concrete data on each node: int, string, null. As well as our ‘complex’, composite data types: an ordered sequence and a <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">variant</a> representing the alternative data types each node can hold.</p>\n<pre><code class=\"language-c++\">// Forward Declaration of Tree Node\nstruct Node;\n\n// Simple \nusing Int = int;\nusing String = std::string;\nusing Null = std::monostate;\n\n// Composite\nusing Sequence = std::vector&lt;Node&gt;;\nusing Data = std::variant&lt;Int, String, Null, Sequence&gt;;\n</code></pre>\n<p>With these type declarations out of the way, our data hierarchy is starting to take shape. Some explanations:</p>\n<ul>\n<li>We forward declare our <strong>Node</strong> class, so that the Sequence type can be aware of it.</li>\n<li>We create aliases for Int, String and Null.</li>\n<li>We declare an alias for the Sequence type: a vector of Nodes. </li>\n<li>Finally, we declare the <strong>Data</strong> class. Each <strong>Node</strong> element will use a data member to hold either an Int, String, Null, or a Sequence of other Nodes.</li>\n</ul>\n<h2 id=\"the-node-class\">The Node Class</h2>\n<p>Now let’s define the Node data type: </p>\n<pre><code class=\"language-c++\">struct Node {\n    std::string m_name;\n    Data m_data;\n    explicit Node(std::string&amp;&amp; name, Data&amp;&amp; data)\n        : m_name(std::move(name)), m_data(std::move(data)) {}\n};\n</code></pre>\n<p>The above definition has two member variables:</p>\n<ul>\n<li><strong>m_name</strong>: A string used to name the node’s ‘field’.</li>\n<li><strong>m_data</strong>: The data the node is holding. Defined as a variant above.</li>\n</ul>\n<p>It also has a single explicit constructor which takes the node name and the data it holds as <a href=\"https://www.learncpp.com/cpp-tutorial/rvalue-references/\">R-value references</a>. Which means data will moved from the incoming instances if possible. If you plan to use this with variables or make copies, more constructors will have to be defined.</p>\n<p>Surprisingly, that’s it! Really. We can already build trees using the syntax demonstrated at the top of the article. Allowing us to develop nested hierarchies dynamically (but with type safety). Notice how the variant constructor accepts each type as needed to initialize the data member.</p>\n<pre><code class=\"language-c++\">auto root =\n    Node(&quot;data&quot;, Sequence({\n        Node(&quot;users&quot;, Sequence({\n            Node(&quot;david&quot;, 12322),\n            Node(&quot;charles&quot;, 2322),\n            Node(&quot;rebecca&quot;, 998)})),\n        Node(&quot;citySize&quot;, Sequence({\n            Node(&quot;nyc&quot;, 8),\n            Node(&quot;toronto&quot;, 4)}))}));\n</code></pre>\n<h2 id=\"traversing-the-structure\">Traversing The Structure</h2>\n<p>Of course, with no way to traverse the structure, it’s useless. Let’s define output stream operators so that we can ‘serialize’ the data structure to <strong>stdout</strong>.</p>\n<p>First let’s do an overload for the <strong>Null</strong> type:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Null&amp; null) {\n    stream &lt;&lt; &quot;null&quot;;\n    return stream;\n}\n</code></pre>\n<p>Very simple. Next let’s overload it for the <strong>Data</strong> (variant) type:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Data&amp; data) {\n    std::visit([&amp;](auto&amp; val) {\n        stream &lt;&lt; val;\n    }, data);\n    return stream;\n}\n</code></pre>\n<p>Here, we are using <a href=\"https://en.cppreference.com/w/cpp/utility/variant/visit\">std::visit</a> to access the variant as it’s current type. Using an auto template lambda keeps things concise. Inside, we simply apply the stream out operator to whatever is in the variant at the time (Int, Null, etc..).</p>\n<p>Next, we can overload the stream operator for the <strong>Node</strong> type. Again, this definition is simple:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Node&amp; node) {\n    std::cout\n        &lt;&lt; &quot;Node{ name=&#39;&quot; &lt;&lt; node.m_name\n        &lt;&lt; &quot;&#39; data=&quot; &lt;&lt; node.m_data &lt;&lt; &quot; }&quot;;\n    return stream;\n}\n</code></pre>\n<p>So far, so good! However, we are missing the crucial overload for <strong>Sequence</strong> (std::vector). Why is this so important? It is what enables the actual traversing to deeper levels. Look carefully:</p>\n<pre><code class=\"language-c++\">template&lt;typename Stream&gt;\nStream&amp; operator&lt;&lt;(Stream&amp; stream, const Sequence&amp; data) {\n    std::cout &lt;&lt; &quot;Sequence[ &quot;;\n    for(const auto&amp; d : data) {\n        std::cout &lt;&lt; d &lt;&lt; &#39; &#39;;\n    }\n    std::cout &lt;&lt; &#39;]&#39;;\n    return stream;\n}\n</code></pre>\n<p>For each child Node in the sequence we use the stream out operator. And this prints out their value. What if a child node is a sequence? Well then the same operator will be called recursively as needed. Viola! We can serialize our data:</p>\n<pre><code class=\"language-c++\">auto root2 =\n    Node(&quot;test&quot;,\n        Sequence({\n            Node(&quot;name&quot;, &quot;Herbert&quot;),\n            Node(&quot;age&quot;, 55)}));\n\n// prints out:\n// Node{ name=&#39;test&#39; data=Sequence[ Node{ name=&#39;name&#39; data=Herbert } Node{ name=&#39;age&#39; data=55 } ] }\nstd::cout &lt;&lt; root2 &lt;&lt; std::endl;\n</code></pre>\n<h2 id=\"programmatically-generating-structure-segments\">Programmatically Generating Structure Segments</h2>\n<p>We have a pretty usable and extensible system already. However, what if we want to transform a vector of custom structs into a canonical <strong>Sequence</strong> in our simple tree data system? All we need to do is write a utility function that iterates over the vector to produce a sequence:</p>\n<pre><code class=\"language-c++\">template&lt;typename T, typename Func&gt;\nSequence vecToSeq(const std::vector&lt;T&gt;&amp; vec, Func func) {\n    Sequence result;\n    for(const auto&amp; v : vec) {\n        result.push_back(func(v));\n    }\n    return result;\n}\n</code></pre>\n<p>Now, we can use this function with a custom function argument to define the structure that will be appended for each data member within the vector:</p>\n<pre><code class=\"language-c++\">// Define custom type\nstruct Custom {\n    int id;\n    std::string name;\n};\n\n// Create vector\nstd::vector&lt;Custom&gt; vec = {\n    {12, &quot;Johnny&quot;}, { 344, &quot;Filber&quot;}, {999, &quot;Jennifer&quot;}\n};\n\n// Use lambda to process each item in vector and output reflecting Node data structure\nauto root3 =\n    Node(&quot;data&quot;, Sequence({\n        Node(&quot;customThings&quot;, vecToSeq(vec, [](const Custom&amp; c) {\n            return Node(&quot;custom&quot;, Sequence({\n                Node(&quot;id&quot;, c.id),\n                Node(&quot;name&quot;, c.name)})); })),\n        Node(&quot;requestId&quot;, 232324)}));\n</code></pre>\n<p>This idea can be expanded to create <strong>toTree()</strong> functions for different types. Perhaps as an exercise, one could generalize the <strong>toTree()</strong> function for all types to allow automatic conversion without direct function calls.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>As you can see, Modern C++ really improves the ability to work with composable data types using utility types such as <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">std::variant</a>. The example presented in this post, provides a simple blueprint for more specific systems. It can extended and modified to support different schema definitions, serialization, and validation. Maybe you want just types with no names? Or a schema with no concrete data? Hopefully this serves a good starting point to direct your thinking. If the curly braces bother you, you play around with template parameter packs. And if you can get by with exclusively compile time generation, maybe you can experiment with using tuples to store the sequences. Have fun!</p>\n<p><a href=\"https://gist.github.com/dgski/d00303b4a8be2d3c109d7a97d77106a3\">Link to Complete Code Example</a></p>\n",
            "author": {
                "name": "David Gorski"
            },
            "tags": [
                   "Types",
                   "C++"
            ],
            "date_published": "2021-03-21T14:30:00-04:00",
            "date_modified": "2023-07-29T14:30:57-04:00"
        }
    ]
}
