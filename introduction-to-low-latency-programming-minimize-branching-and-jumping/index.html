<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Introduction To Low Latency Programming: Minimize Branching And Jumping - Tech @ DG</title><meta name="description" content="This post originally appears as a chapter in my new book: ‘Introduction&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://tech.davidgorski.ca/introduction-to-low-latency-programming-minimize-branching-and-jumping/"><link rel="alternate" type="application/atom+xml" href="https://tech.davidgorski.ca/feed.xml"><link rel="alternate" type="application/json" href="https://tech.davidgorski.ca/feed.json"><meta property="og:title" content="Introduction To Low Latency Programming: Minimize Branching And Jumping"><meta property="og:site_name" content="Tech @ DG"><meta property="og:description" content="This post originally appears as a chapter in my new book: ‘Introduction&hellip;"><meta property="og:url" content="https://tech.davidgorski.ca/introduction-to-low-latency-programming-minimize-branching-and-jumping/"><meta property="og:type" content="article"><link rel="preload" href="https://tech.davidgorski.ca/assets/dynamic/fonts/publicsans/publicsans.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://tech.davidgorski.ca/assets/css/style.css?v=1501a03667953b81505b3bfe44bcde3f"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech.davidgorski.ca/introduction-to-low-latency-programming-minimize-branching-and-jumping/"},"headline":"Introduction To Low Latency Programming: Minimize Branching And Jumping","datePublished":"2024-02-26T15:42","dateModified":"2024-02-26T15:42","description":"This post originally appears as a chapter in my new book: ‘Introduction&hellip;","author":{"@type":"Person","name":"David Gorski","url":"https://tech.davidgorski.ca/authors/david-gorski/"},"publisher":{"@type":"Organization","name":"David Gorski"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><script async defer="defer" data-website-id="f50301b5-5202-4a86-9509-d0a3ed6ed290" src="https://analytics.xantasoft.com/umami.js"></script></head><body><div class="content"><div class="left-bar"><div class="left-bar__inner"><header class="header"><a class="logo" href="https://tech.davidgorski.ca/">Tech @ DG</a></header></div></div><main class="main"><article class="post"><div class="post__meta post__meta--attop"><div class="post__meta--attop__inner"><div class="post__maintag"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#tag"/></svg> Published in <a href="https://tech.davidgorski.ca/tags/c/" class="metadata__maintag">C++</a></div></div></div><div class="main__inner"><div class="post__meta"><div class="post__author"><div><a href="https://tech.davidgorski.ca/authors/david-gorski/" class="post__author__name">David Gorski</a></div></div><div class="post__date"><time datetime="2024-02-26T15:42">Feb 26, 2024</time></div></div><header class="post__header"><h1 class="post__title">Introduction To Low Latency Programming: Minimize Branching And Jumping</h1></header><div class="post__entry"><p><em>This post originally appears as a chapter in my new book: ‘Introduction To Low Latency Programming’, a short and approachable entry into the subject. <a href="https://a.co/d/0U6KOfb">Available now for purchase on Amazon</a>.</em></p><p>This chapter will discuss how branching and jumping in our code affects our runtime performance and how we can avoid them in our effort to reduce the latency of our programs. <strong>Branching</strong> refers to process execution that can go down one of multiple paths. This functionality is provided by ‘check and jump’ instructions. <strong>Jumping</strong> refers to when the program control pointer is changed to a different location in memory rather than progressing to the next sequential instruction. This can be conditional (as a part of branching) or unconditional.</p><h2 id="what-does-it-cost">What Does It Cost?</h2><p>Why do we want to discourage Jumping and/or Branching? Firstly, ‘comparing and jumping’ simply adds more instructions. As mentioned throughout the book, we want to minimize instructions overall. Secondly, branching disrupts the smooth flow of instruction prefetching, meaning if a condition that was not guessed by the branch predictor is encountered, the instruction pipeline has to potentially be flushed and refreshed. A new sequence of instructions will have to be retrieved.</p><p>The branch predictor is an element of CPUs that aims to predict which branch will be taken in our code during runtime. Branch predictors have gotten more and more complex, but the fundamental idea is maintaining branching statistics and using them to determine where a program control address branch will most likely jump to. As mentioned in the previous paragraph, that prediction allows the pre-fetch of upcoming instructions.</p><p>More instructions and instruction pipeline invalidation both contribute to the stalling of program execution. And stalling means we are not running the important instructions that directly contribute to fulfilling the business objectives. In an ideal world, our program would run these ‘golden instructions’ uninhibited.</p><h2 id="examples-of-branching-and-jumping">Examples Of Branching And Jumping</h2><p>The following short list contains <em>some</em> common code constructs which will generate jumping and/or branching instruction constructs:</p><ul><li><strong>Branching and Jumping</strong>: If statements, Chained boolean conditionals, Virtual method calls</li><li><strong>Jumping:</strong> Function calls</li></ul><h2 id="steps-to-reduce-branchingjumping">Steps To Reduce Branching/Jumping</h2><h3 id="branchless-boolean-expressions">Branchless Boolean Expressions</h3><p>Standard boolean expression operations such as <code>&amp;&amp;</code> and <code>||</code> have ‘short-circuiting’ as a feature; if previous boolean expressions evaluate to false, consecutive expressions will not be evaluated:</p><pre><code class="language-c++">const bool andExpression =
  false /*will be evaluated*/ &amp;&amp;
  true /* will not be evaluated*/;
const bool orExpression =
  true /*will be evaluated*/ ||
  false /* will not be evaluated*/;
</code></pre><p>As expected, this introduces branching to our code and should be considered for removal. What do we use instead? You can use the bitwise AND and OR expressions:</p><pre><code class="language-c++">const bool andExpression = false &amp; true; // Both will be evaluated
const bool orExpression = true | false; // Both will be evaluated
</code></pre><p>When should you switch to this approach? There is a simple rule of thumb: switch from logical to bitwise boolean expressions when the overhead cost of branching does not outweigh the cost of evaluating all terms in the expression.</p><p>It still makes sense to use logical boolean expressions if consecutive expressions are expensive to evaluate. Such the following:</p><pre><code class="language-c++">const bool result = cheapCheck() &amp;&amp; expensiveCheck();
</code></pre><p>The short-circuiting branch allows us to avoid the expensive check, which the branchless, bitwise version would not. Tip: For the logical flavor, it makes sense to arrange the expressions in a chain from least to most expensive to enable short-circuiting before the largest computation costs would be incurred.</p><p>Take a good look at the cost of the expression terms before deciding on using the branching or branchless boolean expressions.</p><h3 id="write-code-which-generates-cmov-like-instructions">Write Code Which Generates ‘CMOV’-like instructions</h3><p><code>CMOV</code> is a built-in instruction on the x86 architecture which does a ‘conditional move (copy)’. While spiritually similar to a branch, it is significantly cheaper than real ‘check and jump’. Since we are not writing assembly by hand, we won’t be directly implementing <code>CMOV</code> use. Rather, we will try to use code constructs that will be turned into <code>CMOV</code> instructions. One of these is ternary operator. Regardless, a good compiler will use <code>CMOV</code> when it can, even for if statements (when they simply assign to a value to a variable).</p><p>Ternary operator use:</p><pre><code class="language-c++">const int output = useFortyTwo() ? 42 : 24;
</code></pre><p>Make sure to measure the actual effect of using <code>CMOV</code> instructions with your program and data. Sometimes well-predicted branches can be more performant than <code>CMOV</code>.</p><h3 id="remove-the-use-of-virtual-functions">Remove The Use Of Virtual Functions</h3><p>Virtual function calls perform a jump. When it comes time to call the virtual function, the generated virtual lookup table is consulted for that class. Based on the values in the table, the correct implementation of the method will be ‘jumped to’ to in the executable. This incurs a cost to load the vtable as well a branching jump. Ideally, we will avoid virtual function calls in our programs. If you are using purely virtual classes as a form of interface, you can consider using C++20 concepts instead. They will allow you to constrain generic code and allow you to create ‘interfaces’ via <code>requires</code>.</p><p>Of course, for leveraging dynamic dispatch (runtime specified code execution) there is no alternative to runtime branching / jumping. Other approaches such as using sum types (<code>std::variant</code>) or type erasure all perform the same relative types of instruction. Think about if you really need dynamic dispatch.</p><h3 id="inline-your-functions">Inline Your Functions</h3><p>Function inlining is another feature we can leverage to reduce jumps. In addition to jumping to a different location in our code and dealing with the costs of that, we also don’t have to pay the function call overhead. This overhead includes saving the register states, filling registers and/or the stack with the function arguments, incrementing the stack pointer, saving the stack return location and saving the current program control location. Function inlining puts a copy of the function body being called right at the call site. This can result in some great performance gains as there is no jump and the instruction pipeline is as simple as possible and spatially localized. You can use the GCC <code>always_inline</code> attribute above functions you want to be strictly inlined. For example:</p><pre><code class="language-c++">[[gnu::always_inline]
int function(int a) {
  return a + 11232;
}
</code></pre><p>Even though this function would have most likely already been inlined due to its simplicity, this attribute will forcefully encourage the compiler to do so, provide a warning to us if it is unable to, and also encodes the inlining objective within the code itself for all programmers to see.</p><h2 id="compiler-hints">Compiler Hints</h2><p>If branching is absolutely necessary in your code, you can use compiler hints to provide the compiler with extra information that it cannot infer. Using this information, the compiler will potentially re-order instructions in a way that will make the branch you marked as more ‘likely’ to be more efficient from a conditional branching perspective. This can be done using the <code>__builtin_expect</code> function or from C++20 and above with the <code>likely</code> and <code>unlikely</code> attributes. You can make the <code>__builtin_expect</code> function more ergonomic to use by creating <code>LIKELY</code> and <code>UNLIKELY</code> macros:</p><pre><code class="language-c++">#define LIKELY(x) __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
</code></pre><p>Let’s explore a simple use case and it’s effects. Take a look at this simple function, and it’s corresponding assembly:</p><p>C++:</p><pre><code class="language-c++">void func(int input) {
  if (input == 1) {
    // BRANCH ONE
  } else if (input == 2 ) {
    // BRANCH TWO
  } else {
    // BRANCH THREE
  }
}
</code></pre><p>Assembly:</p><pre><code class="language-asm">func(int): # @func(int)
  movq %rdi, %rax
  leaq 1(%rdi), %rcx
  cmpl $2, %esi
  je .LBB0_3
  cmpl $1, %esi
  jne .LBB0_4
  # BRANCH ONE
  retq
.LBB0_3:
  # BRANCH TWO
  retq
.LBB0_4:
  # BRANCH THREE
  retq
</code></pre><p>Notice that the <code>cmpl</code> instruction is first executed with ‘2’ as the argument. Only after, if we didn’t jump, it will execute with ‘1’. What if we know that the value in <code>$esi</code> is more likely to be equal to ‘1’ and we want to prioritize that branch? Let’s add a <code>LIKELY</code> annotation to our C++ code:</p><pre><code class="language-c++">void func(int input) {
  if (LIKELY(input == 1)) {
    // BRANCH ONE
  } else if (input == 2 ) {
    // BRANCH TWO
  } else {
    // BRANCH THREE
  }
}
</code></pre><p>Now we can observe the different in output assembly:</p><pre><code class="language-asm">func(int): # @func(int)
  pushq %rbx
  cmpl $1, %esi
  jne .LBB0_1
  # BRANCH ONE
  retq
.LBB0_1:
  cmpl $2, %esi
  jne .LBB0_4
  # BRANCH TWO
  retq
.LBB0_4:
  # BRANCH THREE
  retq
</code></pre><p>As you can see, the compiler re-arranged the branching instructions. The comparison of <code>%eri</code> with 1 is now part of the first call to <code>cmpl</code> + <code>jne</code> and if equality is determined we don’t jump anywhere else. Spatially, we are already at the <code>BRANCH ONE</code> code. The compiler also moved the remaining conditionals after the first jump at <code>.LBB0_1:</code>. It is quite apparent that all remaining cases are deprioritized from an optimization standpoint in comparison to <code>BRANCH ONE</code>.</p><p>Now for some semantic rambling. Even though they have been accepted as standard terms, likely and unlikely are not really accurate from a definition perspective. You are not really marking that one conditional branch is more likely than the other to occur. What you are doing is telling the compiler that you want to optimize for this conditional branch. Perhaps <code>OPTIMIZE</code> and <code>UNOPTIMIZE</code> are more accurate terms for our construct. Making your code as readable/understandable/surface-level as possible is always something worth pursuing.</p><h2 id="cheaper-branching">Cheaper Branching</h2><p>Not all ‘branching’ instructions are created equally. Consider the following function that that performs a few <strong>compare and jumps</strong>:</p><pre><code class="language-c++">void processThisString(std::string_view input)
{
  if (input == &quot;production&quot;) {
    processProd(input);
  } else if (input == &quot;RC&quot;) {
    processRC(input);
  } else if (input == &quot;beta&quot;)
    processBeta(input);
  }
}
</code></pre><p>This is a ‘run-of-the-mill’ if statement. However, we have an opportunity here: the comparison set is very constrained. In fact, most the calls to the <code>==</code> operator distill to a <code>memcmp</code> which will short circuit after the first character, since all the first characters in the string literals are different. For example, if the input’s value is “beta”, we will perform two calls to <code>==</code> for nothing. Instead, we can re-write this in a more efficient manner by using the <code>switch</code> construct on that first character:</p><pre><code class="language-c++">void processThisString(std::string_view input)
{
  constexpr auto i = 0;
  switch (input[i]) {
    case &quot;production&quot;[i]: processProd(input); break;
    case &quot;RC&quot;[i]: processRC(input); break;
    case &quot;beta&quot;[i]: processBeta(input); break;
  }
}
</code></pre><p>The compiler will most likely generate a more efficient branching construct using jump tables and binary decision trees since data of only 1 char width is being compared now. A best-case scenario would be if the range of first character values is very limited, because then a single jump table would be used to increment the program control pointer. Of course, this is not cut and dry, because a small set of inputs may cause an if statement to perform better. Always measure! Regardless, this is a good approach to keep in mind for optimization.</p><h2 id="chapter-summary">Chapter Summary</h2><ul><li>Jumping to distant code locations or branching can incur a heavy cost in low latency segments of the code. This is due to added instructions, instruction pipeline de-optimization and cache eviction.</li><li>Examples of Branching/Jumping include: if statements, chained conditionals, virtual method calls, and function calls in general.</li><li>You can avoid branching/jumping by using branchless conditionals, Using ‘CMOV’ instructions, Remove the use of virtual functions and try to inline your functions.</li><li>If branching is unavoidable, try to use a ‘cheaper’ variation of it.</li></ul></div><footer class="post__footer"><div class="post__last-updated">This article was updated on <time datetime="2024-02-26T15:42">Feb 26, 2024</time></div><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-minimize-branching-and-jumping%2F" class="js-share facebook tltp tltp--top" aria-label="Facebook" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-minimize-branching-and-jumping%2F&amp;via=Tech%20%40%20DG&amp;text=Introduction%20To%20Low%20Latency%20Programming%3A%20Minimize%20Branching%20And%20Jumping" class="js-share twitter tltp tltp--top" aria-label="Twitter" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="https://pinterest.com/pin/create/button/?url=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-minimize-branching-and-jumping%2F&amp;media=undefined&amp;description=Introduction%20To%20Low%20Latency%20Programming%3A%20Minimize%20Branching%20And%20Jumping" class="js-share pinterest tltp tltp--top" aria-label="Pinterest" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#pinterest"/></svg> <span>Pinterest</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Ftech.davidgorski.ca%2Fintroduction-to-low-latency-programming-minimize-branching-and-jumping%2F" class="js-share linkedin tltp tltp--top" aria-label="Share with LinkedIn" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div></footer></div></article></main><div class="right-bar"><div class="right-bar__inner"><div class="sidebar"><section class="box promo"><h3 class="box__title">New Book Available Now!</h3><img src="/media/files/ilp.png"><p>Introduction To Low Latency Programming: Learn The Fundamental Ideas Behind High-Performance C++ Code</p><br><a href="https://a.co/d/0U6KOfb"><button>Buy On Amazon</button></a></section><div class="box follow"><a href="https://twitter.com/thedavidgorski" class="tltp tltp--top" aria-label="Twitter"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="https://www.linkedin.com/in/dgski/" class="tltp tltp--top" aria-label="LinkedIn"><svg><use xlink:href="https://tech.davidgorski.ca/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div><div class="box copyright">© David Gorski, 2024</div></div></div></div></div><script defer="defer" src="https://tech.davidgorski.ca/assets/js/scripts.min.js?v=12d8fcd46db8fdc7af6797ec26849875"></script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://tech.davidgorski.ca/assets/js/quicklink.umd.js?v=a52ee49fe4afff274f8c30fe880ddc13"></script><script>window.addEventListener('load', () =>{
      quicklink.listen();
      });</script></body></html>